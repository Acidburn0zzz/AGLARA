<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="network" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title>Network services</title>

  <section>
    <title>Getting a grip on IP addresses</title>

    <para>When you're dealing with a larg(er) network, you'll quickly run into
    the wonderful challenge of properly defining network segments and the
    allowed interaction between them. I personally like to keep segments based
    on its accessibility: internal business services, management services,
    customer business services, internal users, etc. Based on these
    accessibility patterns it is then easier to define the settings (and
    security measurements) for each.</para>

    <para>Within this reference architecture, I will be using IPv6 (as it
    proves to be a nice exercise, but also to show that IPv6 is not something
    to be afraid of) and a logical way of naming the hosts and services using
    DNS names. In this book, the used DNS names will reflect the function and
    "position" of the services in the architecture, but you are not required
    to follow this. Some organizations even want to keep the naming
    conventions of their services (including DNS) as obscure as possible, not
    to give too much information available when a leak occurs.</para>

    <section>
      <title>Example network segment</title>

      <para>The following drawing gives a high-level impression on the network
      segments identified for use in this book. I will be using the
      IPv6<indexterm>
          <primary>IPv6</primary>
        </indexterm> documentation range (2001:db8::/32) but this too is not
      something you need to follow. If your organization is assigned a proper
      IPv6 block, there is also no reason to still use local addresses in your
      organization: the number of IPv6 addresses is
      <emphasis>currently</emphasis> sufficiently large to give each
      server/service in your organization its own address which, through
      routers, gateways and firewalls, is either accessible or not from
      anyplace.</para>

      <figure>
        <title>Example network structure</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/03-networkservices.png"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>IPv6 Addresses and DNS naming</title>

      <para>As we will be using IPv6, a quick run-down of how our network will
      be structured...</para>

      <section>
        <title>IPv6 address scheme</title>

        <para>First, below you'll find an example IPv6 address that could be
        used for a workstation</para>

        <programlisting>2001:0db8:0081:00e2:0000:0204:de89:330f</programlisting>

        <para>In abbreviated form, this becomes</para>

        <programlisting>2001:db8:81:e2::204:de89:330f</programlisting>

        <para>If we use a 64-bit host identifier (which, in IPv6 parlance, is
        called the EUI-64 address) and use the NIC's MAC address (which is 48
        bits), this means that our address can be seen roughly as
        follows:</para>

        <programlisting>2001:0db8:0081:00e2:0000:0204:de89:330f
&lt;------+------&gt;&lt;-+-&gt;&lt;--------+---------&gt;
       |         |           `- 64 bits host identifier
       |         `- 16 bits subnetwork identifier
       `- 48 bits prefix</programlisting>

        <para>In this case,</para>

        <itemizedlist>
          <listitem>
            <para>2001:db8:81 is the prefix assigned to us by our ISP</para>
          </listitem>

          <listitem>
            <para>00e2 is our 16-bits subnet identifier (which we use to
            "regulate" our internal segmentation)</para>
          </listitem>

          <listitem>
            <para>0000:0204:de89:330f is our host identification (which is the
            MAC address + "0000" as padding to make it 64-bit wide).</para>
          </listitem>
        </itemizedlist>

        <para>This gives us plenty of room to create network segmentation
        rules. So for the remainder of this book, we will use the following
        subnet scheme. I have little experience with network segmentation
        rules or design, so if I'm totally missing a point somewhere here,
        please do tell me - I'm eager to learn more about this.</para>

        <itemizedlist>
          <listitem>
            <para>The first 4 bits are set to 0 (and left as a possible
            extension later)</para>
          </listitem>

          <listitem>
            <para>The next 4 bits provide feedback on the environment:
            production (0), testing (1) or lab (2)</para>
          </listitem>

          <listitem>
            <para>The next 4 bits give information about the system or device
            purpose. For instance, networking device (0), storage device (1),
            management server (2), business server (3), DMZ (8), workstation
            VPN (c), portable device (d), internal workstation (e)</para>
          </listitem>

          <listitem>
            <para>The last 4 bits are used for subnets within the defined
            location</para>
          </listitem>
        </itemizedlist>

        <para>So the subnetwork identifier 00e2 given earlier gives us a
        production internal workstation on subnet "2".</para>
      </section>

      <section>
        <title>DNS Naming</title>

        <para>We will use logical names for our components. The domain
        "genfic.com" is used for the organization, "internal.genfic.com" is
        for all internal services.</para>

        <para>For instance, la00010.workstation.internal.genfic.com is an
        internal workstation; rtr01e2.network.internal.genfic.com is a router
        for the network, etc. I tend to prefer having the names consistent
        with a naming convention so that, if I talk about a server called
        gc01n01.virt.internal.genfic.com, it sounds believable when I say it
        is the ganeti cluster 01, node 01 within the production virtualized
        network of the organization.</para>
      </section>
    </section>
  </section>

  <section>
    <title>DNS</title>

    <para>So with our IP address range in place and a imaginary domain name
    structure in place, let's start the setup of our next component -
    DNS<indexterm>
        <primary>DNS</primary>
      </indexterm>.</para>

    <para>DNS, or <emphasis>Domain Name System</emphasis><indexterm>
        <primary>Domain Name System</primary>
      </indexterm>, allows resources on your network to be reachable through a
    human-readable name rather than an obscure ID that is useful for computers
    and routers. To support human-readable names, a DNS service is positioned
    which helps in translating these domain names onto IP addresses and vice
    versa. But next to the name resolving, DNS infrastructure is also
    positioned for various other purposes.</para>

    <figure>
      <title>DNS services</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/03-dnsservice.png"/>
        </imageobject>
      </mediaobject>
    </figure>

    <para>For instance, a mail client can interact with the DNS server of a
    domain to find out where to send e-mails to meant for that domain. This
    information is stored in the MX records of that domain. Recently,
    standards are emerging to counter e-mail spoofing, like SPF
    (<emphasis>Sender Policy Framework</emphasis><indexterm>
        <primary>Sender Policy Framework</primary>
      </indexterm>) and DKIM<indexterm>
        <primary>DKIM</primary>
      </indexterm> (<emphasis>DomainKey Identified Mail</emphasis><indexterm>
        <primary>DomainKey Identified Mail</primary>
      </indexterm>). In case of SPF<indexterm>
        <primary>SPF</primary>
      </indexterm>, a DNS record tells whoever asks it which (IP) addresses
    are allowed to be sending e-mail that seems to originate from its domain.
    Mail servers will then check this record to see if an incoming e-mail
    indeed comes from this location and if not, can reject the e-mail. DKIM on
    the other hand uses digital signatures in the mail itself, where the mail
    servers then check the signature based on the public key that is stored in
    a DNS record of the domain that the mail seems to originate from.</para>

    <para>Having a well performing DNS architecture is extremely important as
    many services you will host will rely on DNS to know how to contact other
    resources: although it is perfectly possible to use IP-only
    configurations, this is a lot less flexible and less transparent - and
    with IPv6, will also make your head spin. Because of that, DNS must
    definitely be high available. Depending on the size and use, you might
    even introduce DNS caching daemons across the network.</para>

    <figure>
      <title>Simple DNS architecture</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/03-dns-highlevel.png"/>
        </imageobject>
      </mediaobject>
    </figure>

    <para>In the above architecture, you notice that two DNS servers are
    positioned in the DMZ<indexterm>
        <primary>DMZ</primary>
      </indexterm> (<emphasis>DeMilitarized Zone</emphasis>), set up in a
    high-available manner (where a slave system pulls in changes from a
    master), and two internally with a similar setup. The distinction between
    the DMZ and the internal ones is that the internal DNS servers will host a
    lot more information needed for our internal architecture, whereas the
    ones on the DMZ only contain information for the publicly available
    services.</para>

    <para>In both cases (DMZ and internal), a configuration management
    database is responsible for providing the addresses and names.</para>

    <section>
      <title>Domain name servers</title>

      <para>Many organizations will host their own domain name servers, and
      perhaps have a third one outside their premises as a fall-back. In our
      reference architecture, we will be using BIND, although I am hoping to
      document djbdns very soon (as a worthy opponent to the tried and true
      BIND<indexterm>
          <primary>BIND</primary>
        </indexterm>). The djbdns implementation has very positive critics,
      both regarding ease of use, performance as well as security. However,
      its main downside currently is that it doesn't fully support IPv6 yet -
      most functionality is supported, but as long as things like dnstrace,
      NS/MX records etc. do not support IPv6, I will be using BIND.</para>

      <para>Name servers such as BIND structure their contents in
      <emphasis>zones</emphasis><indexterm>
          <primary>zones</primary>
        </indexterm>. A zone is a set of IP addresses, hostnames and
      affiliated information, most often for one domain. So genfic.com is one
      domain (one zone) whereas internal.genfic.com is another domain
      (zone).</para>

      <section>
        <title>On BIND</title>

        <para>On the Internet, Berkeleys Internet Name Domain (BIND) server is
        the most popular DNS server to date. It has been plagued by its set of
        security issues, but is still very well supported on Gentoo (and
        other) platforms. The software was originally developed at Berkeley in
        the early 80s in an open source model. Since 2010, the software is
        maintained by the Internet Systems Consortium.</para>

        <para>Because it has such a large history, it has also seen quite a
        few updates and even rewrites. The current major version (BIND 9) is a
        rewrite that was tailored to answer the various secrity-related
        concerns that came from earlier versions. Sadly, even BIND 9 has seen
        its set of security vulnerabilities. Although a new major is in the
        making (BIND 10) it is not made generally available for production use
        yet.</para>

        <para>To support a higher security within BIND, we will of course be
        running it confined within a SELinux domain and using chroot (which,
        together with grSecurity's chroot restrictions, offer a fairly good
        jail for this service).</para>

        <para>Using chrooted services when you have a mandatory access control
        system in place might sound like a weird decision. However, this does
        make perfect sense. The MAC system in use within this architecture is
        SELinux, which uses a labeled approach on how resources are accessed.
        A service that has read access to, say, generic system configuration
        files, is allowed access (as long as the standard Linux access
        controls allow this too of course) to all files labeled as such. In a
        non-chrooted environment, it is very probable that many files are
        labeled with "generic system configuration file". When a vulnerability
        in the software is exploited and that software had read access to
        "generic system configuration file", that software can still leak
        information towards the hacker without the Mandatory Access Control
        system prohibiting this (as the service was allowed access to begin
        with). Within a chrooted environment, the number of files that are
        labeled as such are limited to those needed to run the service -
        nothing more, nothing less.</para>
      </section>

      <section>
        <title>Flows</title>

        <para>Naming services are an important part in an architecture. If
        your systems cannot resolve a hostname to an IP address, they will
        most likely not function correctly. We will implement a master-slave
        architecture, but where we can "upgrade" the slave to the master role
        if necessary. We will be using BIND's master/slave functionality,
        chrooted into <filename>/var/named/chroot</filename>.</para>

        <figure>
          <title>High-level BIND architecture</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/03-BIND.png"/>
            </imageobject>
          </mediaobject>
        </figure>

        <para>For the BIND architecture, we see the following feeds or
        activities involved:</para>

        <itemizedlist>
          <listitem>
            <para><emphasis>XFER PULL</emphasis> is initiated from the
            secundary name server (the slave) which periodically connects to
            the master to get changes on the zone files. This is used to
            provide high availability for the service, and to replicate
            changes sufficiently fast towards all name servers. The BIND
            master can also signal the slaves that updates are available,
            offering faster replication of changes.</para>
          </listitem>

          <listitem>
            <para><emphasis>CMDB FEED</emphasis> is a file transfer initiated
            from the central configuration management system (Puppet) which
            contains node information (IP address versus expected hostname and
            domain name) and is used to locally regenerate the zone
            files.</para>
          </listitem>

          <listitem>
            <para><emphasis>BACKUP</emphasis> is what it sais it is - a
            backup. Having backup (and restore of course) services available
            allows fast recovery when things go wrong, or when a human error
            has occurred.</para>
          </listitem>
        </itemizedlist>

        <para>We explicitly mention the system logger here as it will be
        configured to read log entries from the log socket in the chrooted
        environment.</para>
      </section>

      <section>
        <title>Administration</title>

        <para>Administering the BIND solution is done through two main tracks:
        puppet, and SSH.</para>

        <figure>
          <title>BIND administration</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/03-bindadmin.png"/>
            </imageobject>
          </mediaobject>
        </figure>

        <para>Puppet is used as the central configuration management tool in
        this reference architecture. For the BIND service, two major
        activities are done through it:</para>

        <itemizedlist>
          <listitem>
            <para>Configuration of BIND is done through the Puppet service by
            the BIND administrator. This includes initial setup of the BIND
            service, configuration of BIND (parameters and tuning), updates
            &amp; patching and more.</para>
          </listitem>

          <listitem>
            <para>Creation and removing of (other) services is done by the
            respective system administrators. Whenever they create an
            additional server or service in Puppet, a change is pushed to the
            BIND server with the newly created hostname and IP address.</para>
          </listitem>
        </itemizedlist>

        <para>The second interface, SSH, is used to directly control a BIND
        service. You will use SSH for performing administrative tasks such as
        restarting the BIND service, fixing problems and more. SSH is only
        provided for BIND administrators, not for other roles in the
        organization.</para>
      </section>

      <section>
        <title>Monitoring</title>

        <para>For monitoring the BIND services, we will configure nagios to do
        DNS lookups against all defined name servers. From an availability
        perspective, there are most likely three things we need to keep an eye
        on:</para>

        <itemizedlist>
          <listitem>
            <para>Is the BIND service still available, and</para>
          </listitem>

          <listitem>
            <para>Is the BIND service responding within the performance
            margins that we like, and</para>
          </listitem>

          <listitem>
            <para>Does the slave DNS service have the same data (serial) as
            the primary DNS server?</para>
          </listitem>
        </itemizedlist>

        <para>If you are going to use DNSSEC, it might also be a good idea to
        provide two additional checks:</para>

        <itemizedlist>
          <listitem>
            <para>Do the records and their signatures still match (or
            preferably, does the signature match and can it be traced and
            validated all up to the root chain), and</para>
          </listitem>

          <listitem>
            <para>Are the ZSKs (Zone Signing Keys) rotated sufficiently (and
            newer ones available)</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Operations</title>

        <para>When running, BIND is a fairly simple daemon from an
        architectural point of view.</para>

        <figure>
          <title>Standard operation usage of BIND</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/03-bind-operations.png"/>
            </imageobject>
          </mediaobject>
        </figure>

        <para>Network-wise, it interacts with two other services: other BIND
        servers (for zone transfers) and with standard clients (for querying
        the DNS records).</para>

        <para>On the system, the interaction is mainly with the system logger
        (over a socket). The resources that the named daemon uses are its
        configuration (and cryptographic keys if applicable) and its zone
        files.</para>
      </section>

      <section>
        <title>User management</title>

        <para>DNS services are, by default, anonymous services. Some access
        controls are often placed to restrict who can (from a network point of
        view) query the DNS service or send/receive data from (in case of pull
        requests/zone transfers), and more tight access controls (like shared
        keys) can be used to further authenticate such activities. However,
        real "users" are not known in the BIND setup.</para>

        <para>That being said, the SELinux policy for BIND does provide an
        administrative interface, allowing you to define roles that are
        allowed to administer a BIND environment without granting those users
        full administrative access on your system. The interface is called
        <interfacename>bind_admin</interfacename> and takes two arguments: the
        user domain allowed access and its role.</para>

        <programlisting>bind_admin(&lt;userdomain&gt;, &lt;userrole&gt;)</programlisting>
      </section>

      <section>
        <title>Security</title>

        <para>DNS services are widely available and are a high-profile target
        for hackers and malicious persons or organizations. If someone could
        change the DNS records for your domain, then it can have users visit
        different sites (which are made to look like your own site) which
        might allow the perpetrator to get access to authentication
        credentials, confidential information and more. He only needs to
        modify the IP address replies that the DNS server would give and have
        them point to its own website. This is called DNS hijacking, and does
        not only introduce the risk of "spoofed websites", but also changes in
        e-mail flows (for instance, the malicious user changes the MX records
        to point to his own e-mail server so he can watch and even modify
        e-mail communication to your own domain).</para>

        <para>To provide some level of protection against these threats, a
        number of security changes are recommended:</para>

        <itemizedlist>
          <listitem>
            <para>If your registrar supports DNSSEC<indexterm>
                <primary>DNSSEC</primary>
              </indexterm>, then enable DNSSEC on your zones as well. With
            DNSSEC, the resource records in your zone are digitally signed (by
            your own keys) and your key is signed by the parent domain (hence
            the need for the registrar and higher-level domains to support it
            too).</para>

            <para>This provides some additional protection against DNS
            hijacking, although it is not perfect (end users must use DNSSEC
            for their lookups and should have a valid trusted keystore
            containing the root DNS server keys).</para>
          </listitem>

          <listitem>
            <para>Enable SPF (Sender Policy Framework) so that mail servers
            who receive an e-mail that is supposed to be sent by you (or
            someone in your domain), then the mail server can check the origin
            address against the SPF records in your DNS to validate if they
            match or not.</para>
          </listitem>

          <listitem>
            <para>Enable DKIM (DomainKey Identified Mail) to sign outgoing
            e-mails and provide the DKIM public key in your DNS records so
            DKIM-supporting mail servers can validate the signatures.</para>
          </listitem>
        </itemizedlist>
      </section>
    </section>

    <section>
      <title>Installing and configuring BIND</title>

      <para>Configuring BIND on Gentoo Linux is fairly similar as configuring
      BIND on other platforms. There are plenty of good and elaborate
      resources on BIND configuration on the Internet, some of which are
      mentioned at the end of this chapter.</para>

      <section>
        <title>Installing bind</title>

        <para>First, install net-dns/bind. An overview of the USE flags used
        here is shown as well as output of the equery command.</para>

        <programlisting># <command>equery u bind</command>
[ Legend : U - final flag setting for installation]
[        : I - package is installed with flag     ]
[ Colors : set, unset                             ]
 * Found these USE flags for net-dns/bind-9.9.2_p1:
 U I
 - - berkdb      : Adds support for sys-libs/db (Berkeley DB for MySQL)
 + + caps        : Use Linux capabilities library to control privilege
 + + dlz         : Enables dynamic loaded zones, 3rd party extension
 - - doc         : Adds extra documentation (API, Javadoc, etc). It is recommended to enable per package instead of globally
 - - filter-aaaa : Enable filtering of AAAA records over IPv4
 - - geoip       : Add geoip support for country and city lookup based on IPs
 - - gost        : Enables gost OpenSSL engine support
 - - gssapi      : Enable gssapi support
 - - idn         : Enable support for Internationalized Domain Names
 + + ipv6        : Adds support for IP version 6
 - - ldap        : Adds LDAP support (Lightweight Directory Access Protocol)
 - - mysql       : Adds mySQL Database support
 - - odbc        : Adds ODBC Support (Open DataBase Connectivity)
 - - postgres    : Adds support for the postgresql database
 - - python      : Adds optional support/bindings for the Python language
 - - rpz         : Enable response policy rewriting (rpz)
 - - rrl         : Response Rate Limiting (RRL) - Experimental
 - - sdb-ldap    : Enables ldap-sdb backend
 + + ssl         : Adds support for Secure Socket Layer connections
 - - static-libs : Build static libraries
 + + threads     : Adds threads support for various packages. Usually pthreads
 + + urandom     : Use /dev/urandom instead of /dev/random
 + + xml         : Add support for XML files

# <command>emerge net-dns/bind net-dns/bind-tools</command>
# <command>rc-update add named default</command></programlisting>

        <para>Next, edit <filename>/etc/conf.d/named</filename> and set the
        CHROOT variable. Make sure that this destination directory doesn't
        exists, or is empty otherwise. Also set CHROOT_NOMOUNT as we will be
        manging the files directly inside the chroot:</para>

        <programlisting>CHROOT="/var/named/chroot"
CHROOT_NOMOUNT="1"</programlisting>

        <para>Finally, we will set up the chroot environment so that BIND can
        run in it. Now, our friendly package maintainer at Gentoo has made
        this easier for non-SELinux users:</para>

        <programlisting># <command>emerge --config =net-dns/bind-9.8.1_p1</command></programlisting>

        <para>With SELinux enabled though, you either need to (temporarily)
        allow the following privileges:</para>

        <programlisting>## SELinux allow rule
allow portage_t var_t:chr_file { create getattr setattr };</programlisting>

        <para>or you can opt to temporarily run portage_t in permissive
        mode:</para>

        <programlisting># <command>semanage permissive -a portage_t</command>
(... run emerge --config ...)
# <command>semanage permissive -d portage_t</command></programlisting>

        <para>This will prepare the chroot for you. Finish off by resetting
        the right SELinux file contexts on the chroot:</para>

        <programlisting># <command>setfiles -r /var/named/chroot /etc/selinux/strict/contexts/files/file_contexts /var/named/chroot</command></programlisting>

        <para>At the end of the steps, emerge will ask you to edit your system
        logger configuration to capture logging events from the chrooted
        environment as well.</para>

        <programlisting># <command>vim /etc/syslog-ng/syslog-ng.conf</command>
(... Add the next line ...)
source jail { unix-stream("/var/named/chroot/dev/log"); };</programlisting>
      </section>

      <section>
        <title>Initial configuration</title>

        <para>We will start with an initial configuration of BIND, meant for a
        master DNS server.</para>

        <para>Let's start with
        <filename>/var/named/chroot/etc/bind/named.conf</filename><indexterm>
            <primary>named.conf</primary>
          </indexterm>:</para>

        <programlisting>options {
  directory "/var/bind";
  pid-file "/var/run/named/named.pid";
  statistics-file "/var/run/named/named.stats";
  listen-on { 127.0.0.1; };
  listen-on-v6 { 2001:db8:81:21::ac:98ad:5fe1; };
  allow-query { any; };
  zone-statistics yes;
  allow-transfer { 2001:db8:81:22::ae:6b01:e3d8; };
  notify yes;
  recursion no;
  version "[nope]";
};

# Access to DNS for local addresses (i.e. genfic-owned)
view "local" {
  match-clients { 2001:db8:81::/48; };
  recursion yes;
  zone "genfic.com" { type master; file "pri/com.genfic"; };
  zone "1.8.0.0.8.b.d.0.1.0.0.2.ip6.arpa" { type master; file "pri/1.8.0.0.8.b.d.0.1.0.0.2.ip6.arpa"; };
};</programlisting>

        <para>That's it. The configuration will have this installation work as
        the master DNS server and will (only) accept DNS requests from IPv6
        addresses within our IP range. For these requests, we use the
        <filename>pri/com.genfic</filename> file (which is our "zone" file
        that will contain the DNS records) and
        <filename>pri/1.8.0.0.8.b.d.0.1.0.0.2.ip6.arpa</filename> for the
        reverse lookups. I like to keep the zone files named after the domain
        (zone) itself - not only is it more logical and less error prone, but
        many BIND utilities can handle this logic easier. For instance, with
        dnssec-related commands, you do not need to pass on the domain in the
        option if the file is named after the domain.</para>

        <para>Sadly, the name of the reverse lookup is fairly difficult to
        work with by people. For this reason, I always create a symbolic link
        that makes this a lot easier:</para>

        <programlisting># <command>ln -s 1.8.0.0.8.b.d.0.1.0.0.2.ip6.arpa genfic.com.inv</command></programlisting>

        <para>This way, I know that &lt;domain&gt;.inv is a symbolic link
        pointing to the reverse lookup zone definition.</para>

        <para>For the slave server, the setup is fairly similar:</para>

        <itemizedlist>
          <listitem>
            <para>do not set the <parameter>allow-transfer</parameter> though.
            It is a slave server.</para>
          </listitem>

          <listitem>
            <para>set the type of the zone's to "<parameter>slave</parameter>"
            instead and add in <userinput>masters {
            2001:db8:81:21::ac:98ad:5fe1; }</userinput> to each zone. That
            will tell BIND what the master of this particular zone is.</para>
          </listitem>

          <listitem>
            <para>on the slave, you will also need to set the
            <parameter>named_write_master_zones</parameter> SELinux boolean to
            "on" so that the named_t domain can write to the cache
            location.</para>
          </listitem>
        </itemizedlist>

        <para>Finally, set the initial zone files for the organization.</para>

        <programlisting># <command>cat /var/named/chroot/var/bind/pri/com.genfic</command>
$TTL 1h ;
$ORIGIN genfic.com.
@       IN      SOA     ns.genfic.com. ns.genfic.com. (
                        2012041101
                        1d      
                        2h
                        4w
                        1h )

        IN      NS      ns.genfic.com.
        IN      NS      ns2.genfic.com.
        IN      MX      10      mail.genfic.com.
        IN      MX      20      mail2.genfic.com.

genfic.com.     IN      AAAA    2001:db8:81:80::dd:13ed:c49e;
ns              IN      AAAA    2001:db8:81:21::ac:98ad:5fe1;
ns2             IN      AAAA    2001:db8:81:22::ae:6b01:e3d8;
www             IN      CNAME   genfic.com.;
mail            IN      AAAA    2001:db8:81:21::b0:0738:8ad5;
mail2           IN      AAAA    2001:db8:81:22::50:5e9f:e569;
; (...)</programlisting>

        <programlisting># <command>cat /var/named/chroot/var/bind/pri/com.genfic.inv</command>
$TTL 1h ;
@       IN      SOA     1.8.0.0.8.b.d.0.1.0.0.2.ip6.arpa ns.genfic.com. (
                        2012041101
                        1d
                        2h
                        4w
                        1h )

        IN      NS      ns.genfic.com.
        IN      NS      ns2.genfic.com.

$ORIGIN 1.8.0.0.8.b.d.0.1.0.0.2.ip6.arpa.

1.e.f.5.d.a.8.9.c.a.0.0.0.0.0.0.1.2.0.0         IN      PTR     ns.genfic.com.
8.d.3.e.1.0.b.6.e.a.0.0.0.0.0.0.2.2.0.0         IN      PTR     ns2.genfic.com.
; (...)</programlisting>

        <para>With the configuration done, you can now start the named
        daemon.</para>

        <programlisting># <command>run_init rc-service named start</command></programlisting>
      </section>

      <section>
        <title>Hardening zone transfers</title>

        <para>You can perform additional hardening on the BIND system by
        introducing transaction signatures (TSIG<indexterm>
            <primary>TSIG</primary>
          </indexterm>). To do so, create a shared secret (key) with
        <command>dnssec-keygen</command>. The generated key is then added to
        the named.conf file like so:</para>

        <programlisting># <command>dnssec-keygen -a HMAC-MD5 -b 128 -n HOST secundary</command>
# <command>cat Ksecundary.*.key</command>
secundary. IN KEY 512 3 157 d8fhe2frgY24WFedx348==</programlisting>

        <programlisting>(... In named.conf ...)
key secundary { algorithm hmac-md5; secret "d8fhe2frgY24WFedx348=="; };

(... In named.conf's zone definition ...)
allow-update { key secundary; };</programlisting>

        <para>In the slave's configuration, add in an entry for the master and
        refer to this key as well.</para>

        <programlisting>(... In named.conf ...)
key secundary { algorithm hmac-md5; secret "d8fhe2frgY24WFedx348=="; };
server 2001:db8:81:21::ac:98ad:5fe1 { keys { secundary; }; };</programlisting>

        <para>You cannot use the TSIG together with an IP address list though,
        so either use the keys or use IP addresses.</para>
      </section>

      <section>
        <title>Hardening DNS records (DNSSEC)</title>

        <para>To use DNSSEC, you first need to create two keypairs. One is the
        KSK (Key Signing Key) and is a long-term keypair. It will be used to
        sign the ZSKs (Zone Signing Keys) used for the zones. ZSKs are used to
        sign most DNS records, whereas the KSK is used to sign the ZSK. It is
        also the KSK which is signed by the "higher-level" domain.</para>

        <programlisting># <command>cd /var/named/chroot/etc/bind</command>
# <command>mkdir keys &amp;&amp; cd keys</command>
# <command>dnssec-keygen -a RSASHA256 -b 2048 -3 genfic.com</command>
# <command>dnssec-keygen -a RSASHA256 -b 2048 -3 -fk genfic.com</command>
# <command>chown -R named:named .</command></programlisting>

        <para>Next, update the BIND configuration to use these keys. Below you
        find the updated named.conf file with highlights where changes were
        made:</para>

        <programlisting>options {
  directory "/var/bind";
  pid-file "/var/run/named/named.pid";
  statistics-file "/var/run/named/named.stats";
  listen-on { 127.0.0.1; };
  listen-on-v6 { 2001:db8:81:21::ac:98ad:5fe1; };
  allow-query { any; };
  zone-statistics yes;
  allow-transfer { 2001:db8:81:22::ae:6b01:e3d8; };
  notify yes;
  recursion no;
  version "[nope]";
<command>  dnssec-validation yes;
  dnssec-lookaside auto;
  dnssec-enable yes;
  key-directory "/etc/bind/keys";
  allow-new-zones yes;</command>
};
view "local" {
  match-clients { 2001:db8:81::/48; };
  recursion yes;
  zone "genfic.com" {
        type master;
        file "pri/genfic.com";
<command>        inline-signing yes;
        auto-dnssec maintain;</command>
  };
  zone "1.8.0.0.8.b.d.0.1.0.0.2.ip6.arpa" {
        type master;
        file "pri/genfic.com.inv";
<command>        inline-signing yes;
        auto-dnssec maintain;</command>
  };
};

<command>include "/etc/bind/bind.keys";</command></programlisting>

        <para>Make sure that the named daemon has write access to the zone
        files (both through the SELinux
        <parameter>named_write_masters_zone</parameter> boolean as well as
        regular Linux permissions) as it will save the signed records next to
        the regular file.</para>

        <para>With these changes made, restarting the named daemon enables
        DNSSEC support.</para>
      </section>
    </section>

    <section>
      <title>Using bind</title>

      <para>The bind server is started and managed through its init
      script.</para>

      <programlisting># <command>run_init rc-service named start</command></programlisting>

      <section>
        <title>Validating configurations</title>

        <para>The installed utilities can help you troubleshoot configuration
        issues.</para>

        <para>The <command>named-checkconf</command> tool will verify the
        syntax of your named.conf file and report any issues it finds.</para>

        <para>With <command>named-checkzone</command>, you can validate the
        syntax of your zone files.</para>
      </section>

      <section>
        <title>Checking named results</title>

        <para>A good tool to query your name servers (to make sure they
        function correctly) is dig.</para>

        <para>First, let's see if the name server is up and running:</para>

        <programlisting># <command>ping6 -n -c 1 ns.genfic.com</command></programlisting>

        <para>If the host resolves (locally) and replies, then at least your
        local network is working. Let's query the name server then, asking for
        the IP address of mail.genfic.com:</para>

        <programlisting># <command>dig @ns.genfic.com mail.genfic.com AAAA</command></programlisting>

        <para>To get a reverse lookup, use -n -x:</para>

        <programlisting># <command>dig -x 2001:db8:81:22::ae:6b01:e3d8 @ns.genfic.com </command></programlisting>

        <para>If you do not want to see all the output of dig, but just the
        answer, add in "+short".</para>

        <programlisting># <command>dig mail.genfic.com AAAA @ns.genfic.com +short</command>
2001:db8:81:21:0:b0:738:8ad5</programlisting>
      </section>

      <section>
        <title>Sending DNSSEC DS Records to the parent domain</title>

        <para>When your DNS service provides DNSSEC, you will need to upload
        your Delegation Signer information to the parent domain service. This
        DS record will then be stored in the parent zone, and thus get its own
        digital signature so clients can check the validity of the key. To
        push the DS records, you can generate those using
        <command>dnssec-dsfromkey</command> against the KSK:</para>

        <programlisting># <command>grep key-signing *.key</command>
K1.8.0.0.8.b.d.0.1.0.0.2.ip6.arpa.+008+41569.key:; This is a key-signing key, keyid 41569, for 1.8.0.0.8.b.d.0.1.0.0.2.ip6.arpa.
Kgenfic.com.+008+51397.key:; This is a key-signing key, keyid 51397, for genfic.com
# <command>dnssec-dsfromkey Kgenfic.com.+008+51397.key</command>
genfic.com. IN DS 51397 8 1 B23D4D54B971A2A835A31B2B1AF24AB43E2C8EA2
genfic.com. IN DS 51397 8 2 323F009E2B952F3247DC78BA85AA38A9C798B5FE129A78935CCC4686 C5F02A14</programlisting>

        <para>You can now submit these records (the first is a SHA1 checksum
        of the DNSKEY and owner information, the second one a SHA256 checksum
        of the same data) to your registrar. Some support an automated way to
        handle this, others still require you to send it manually. Just make
        sure it is sent securely - not that the information is private, but if
        you notice that your registrar doesn't take proper measures to make
        sure it is you handing over the DS records, then the entire idea of a
        secure DNS falls down.</para>
      </section>

      <section>
        <title>Refreshing DNSSEC Zone Signing Keys</title>

        <para>While creating the keys, <command>dnssec-keygen</command>
        supports timing information to allow for proper roll-over of the zone
        signing keys. This information includes a publication date (when will
        the new key be published in your DNS records, even if the key is not
        used yet), activation date (when will the new key be used to sign
        records), inactivation date and deletion date. As we are refreshing
        the zone keys, you do not need to resubmit DS records (as those are
        made against the key-signing key, not zone-signing key).</para>

        <para>When made available, run <command>rndc loadkeys
        genfic.com</command> to reload the keys for the genfic.com
        domain.</para>

        <para>What if we refresh the key signing keys? In that case, you do
        need to send over the new DS records to the parent domain. I find it
        more proper to do double-signing when refreshing KSK whereas using
        roll-over periods for ZSK, as the KSK only signs one record (the
        DNSKEY one) whereas the ZSK signs many more records. Double-signing
        would increase the amount of records immensely in case of the
        ZSK.</para>
      </section>

      <section>
        <title>Pushing changes</title>

        <para>You can push changes to BIND using the
        <command>nsupdate</command><indexterm>
            <primary>nsupdate</primary>
          </indexterm> application. You'll need to make sure the system from
        which you run this has the proper rights in BIND (through the
        <parameter>allow-update</parameter> directive). Once set up though,
        you can use this to create the feed from, for instance, a
        configuration management database.</para>

        <programlisting>$ <command>cat changes.txt</command>
server 2001:db8:81:21::ac:98ad:5fe1 53
update add mail2.internal.genfic.com 3600 AAAA 2001:db8:81:22::50:5e9f:e569
$ <command>nsupdate ./changes.txt</command></programlisting>
      </section>
    </section>

    <section>
      <title>Logging</title>

      <para>In case of DNS services, we want to log at least the following
      events:</para>

      <itemizedlist>
        <listitem>
          <para>queries made against the DNS server (timestamp, source
          address, query itself) and the answers given</para>
        </listitem>

        <listitem>
          <para>modifications made on the configuration (timestamp, source
          address, modification)</para>
        </listitem>
      </itemizedlist>

      <para>Whereas the logging of the queries can be done in local log files,
      modifications need to be sent to a remote location (and might be stored
      locally too).</para>

      <para>rndc querylog (enable/disable, found in messages):</para>

      <section>
        <title>Configuring logging</title>

        <para>BIND by default will log through the system logger. This allows
        us to store the logging information where we please, perhaps even
        moving the data towards other systems (or at least outside the chroot
        environment).</para>

        <para>However, BIND does not log queries immediately - you need to
        tell it to toggle querylogging (I call it toggle, since running the
        same command will disable it again):</para>

        <programlisting># <command>rndc querylog</command></programlisting>

        <para>Once enabled, queries will appear in the system log like
        so:</para>

        <programlisting>Dec 17 09:15:30 ns named[3721]: client 2001:db8:81:21:0:ac:98ad:5fe1#48818 \
  (mail.genfic.com): view local: query: mail.genfic.com IN AAAA +ED \
  (2001:db8:81:21:0:ac:98ad:5fe1)
Dec 17 09:16:07 ns named[3721]: client 2001:db8:81:21:0:ac:98ad:5fe1#54273 \
  (ns2.genfic.com): view local: query: ns2.genfic.com IN AAAA +ED \
  (2001:db8:81:21:0:ac:98ad:5fe1)</programlisting>

        <para>In the above case, the queries came from the same client (one
        with IPv6 address ending in :5fe1) and the client wanted to know the
        IPv6 addresses of mail.genfic.com and ns2.genfic.com.</para>
      </section>
    </section>
  </section>

  <section>
    <title>DHCP</title>

    <para>When you have systems that require dynamically allocated IP
    addresses, you will need a DHCP service.</para>

    <para>DHCP<indexterm>
        <primary>DHCP</primary>
      </indexterm> stands for Dynamic Host Configuration Protocol and is the
    de-facto standard for dynamic IP allocation. In our architecture, we will
    be using DHCP for the workstations, VPN and other devices that are in the
    "bring your own device" pool, because all those devices might be started
    on different locations and as such are difficult to manage with fixed IP
    addresses.</para>

    <section>
      <title>DHCP Architecture</title>

      <para>Within our architecture, we will be positioning two DHCP servers
      internally, in an active/standby setup. Because ISC's DHCP (which we
      will use here) does not support high-available mode for IPv6 yet, we are
      forced to use a "standard" setup. When ISC supports failover mode for
      IPv6 as well, I will update the architecture accordingly.</para>

      <para>We also implement DHCP relay daemons within the target subnets
      where the workstations and other devices will need one.</para>

      <section>
        <title>General architecture</title>

        <para>The next figure displays the general architecture being put in
        place for our needs.</para>

        <figure>
          <title>General DHCP architecture</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/03-dhcp.png"/>
            </imageobject>
          </mediaobject>
        </figure>

        <para>The given architecture is fairly simple:</para>

        <itemizedlist>
          <listitem>
            <para>The workstation requests a dynamic IP address
            (<emphasis>Request IP</emphasis>) which gets captured by the relay
            server.</para>
          </listitem>

          <listitem>
            <para>The relay server forwards the request (<emphasis>Forward
            request</emphasis>) to the DHCP servers. They eventually complete
            the DHCP handshake through the relay server</para>
          </listitem>
        </itemizedlist>
      </section>
    </section>

    <section>
      <title>Installation and configuration</title>

      <para>The installation and configuration of DHCP is fairly simple and,
      similar to BIND, uses flat files for its configuration.</para>

      <section>
        <title>Installation</title>

        <para>First install the DHCP server. We will use ISC's DHCP server
        here.</para>

        <programlisting># <command>emerge dhcp</command></programlisting>

        <para>Do the same on the relay servers. We will, however, not start
        the main server there but the relay service only.</para>

        <para>Next, edit <filename>/etc/conf.d/dhcpd</filename> to configure
        the DHCP daemon to use IPv6.</para>

        <programlisting># <command>cat /etc/conf.d/dhcpd</command>
DHCPD_OPTS="-6"</programlisting>
      </section>

      <section>
        <title>Master DHCP server</title>

        <para>On the master DHCP server, configure the
        <filename>/etc/dhcp/dhcpd.conf</filename> file similar to the
        following:</para>

        <programlisting># <command>cat /etc/dhcp/dhcpd.conf</command>
ddns-update-style interim;

authorative;

default-lease-time 600;
max-lease-time 7200;

subnet6 2001:db8:81:e2::/64 {
  range6 2001:db8:81:e2::f00 2001:db8:81:e2::fff;
  option dhcp6.name-servers 2001:db8:81:21::ac:98ad:5fe1, 2001:db8:81:22::ae:6b01:e3d8;
  option dhcp6.domain-search "workstation.internal.genfic.com";
}

subnet6 2001:db8:81:21::/64 {
  # Empty but must be declared so DHCPd starts
}</programlisting>

        <para>You can also have the DHCP server give a fixed IP address to a
        system based on its MAC address. This is handled through the host
        parameter:</para>

        <programlisting>group {
  use-host-decl-names on;

  host la00010 {
    hardware ethernet "e8:0c:11:31:9f:0b";
    fixed-address la00010.workstation.internal.genfic.com;
    option host-name "la00010";
  }
}</programlisting>

        <para>Finally, start the service and register it to automatically
        start during boot.</para>

        <programlisting># <command>rc-update add dhcpd default</command>
# <command>rc-service dhcpd start</command></programlisting>

        <para>Our secundary system will have a similar setup, but will use a
        separate range (say :1000 to :10ff).</para>
      </section>

      <section>
        <title>Relay services</title>

        <para>When you configure a relay service, edit
        <filename>/etc/conf.d/dhcrelay</filename> and set the DHCRELAY_OPTS
        accordingly.</para>

        <programlisting># <command>cat /etc/conf.d/dhcrelay</command>
DHCRELAY_OPTS="-6 -l eth0 -u 2001:db8:81:21::f4:3303:40f4%eth0 -u 2001:db8:81:22::5f:3853:fe78%eth0"</programlisting>

        <para>You also need to edit <filename>/etc/init.d/dhcrelay</filename>
        currently as it forces two options that are only valid for
        IPv4:</para>

        <programlisting># <command>vim /etc/init.d/dhcrelay</command>
(... 1. look for $(printf " -i %s" ${IFACE}) and delete it ...)
(... 2. look for DHCRELAY_SERVERS and remove it ...)
(... End result should be something like:)
start-stop-daemon --start --exec /usr/sbin/dhcrelay \
  -- -q ${DHCRELAY_OPTS}</programlisting>

        <para>Then start up the relay service and make sure it starts at boot
        time as well.</para>

        <programlisting># <command>rc-update add dhcrelay default</command>
# <command>rc-service dhcrelay start</command></programlisting>
      </section>
    </section>

    <section>
      <title>Logging</title>

      <para>For the DHCP service, we want to have logs about the DHCP queries
      made as well as their reply. These logs can be stored locally.</para>

      <para>TODO</para>
    </section>
  </section>

  <section>
    <title>Resources</title>

    <para>IP addresses, segmentation and IPv6:</para>

    <itemizedlist>
      <listitem>
        <para><link
        xlink:href="http://www.sans.org/reading_room/whitepapers/hsoffice/design-secure-network-segmentation-approach_1645">Design
        Secure Network Segmentation Approach</link>, article on SANS</para>
      </listitem>

      <listitem>
        <para><link
        xlink:href="http://ipv6.com/articles/general/IPv6-Addressing.htm">IPv6
        Addressing</link> (IPv6.com)</para>
      </listitem>
    </itemizedlist>

    <para>On ISC BIND:</para>

    <itemizedlist>
      <listitem>
        <para><link
        xlink:href="http://en.gentoo-wiki.com/wiki/BIND">BIND</link>
        (Gentoo-wiki.com)</para>
      </listitem>

      <listitem>
        <para><link
        xlink:href="http://www.zytrax.com/books/dns/ch7/xfer.html">DNS BIND
        Zone Transfers and Updates</link> (Zytrax.com); this is part of a
        bigger and interesting reference on BIND9 on Linux/Unix
        systems.</para>
      </listitem>

      <listitem>
        <para><link
        xlink:href="http://www.cyberciti.biz/faq/unix-linux-bind-named-configuring-tsig/">Transaction
        Signatures Configuration</link> (Cyberciti.biz)</para>
      </listitem>

      <listitem>
        <para><link
        xlink:href="http://benchmarks.cisecurity.org/en-us/?route=downloads.show.single.bind.200">CISecurity
        BIND Benchmark</link> (CISecurity.org)</para>
      </listitem>

      <listitem>
        <para><link
        xlink:href="http://backreference.org/2010/11/17/dnssec-verification-with-dig/">DNSSEC
        validation with dig</link> (backreference.org)</para>
      </listitem>

      <listitem>
        <para><link
        xlink:href="https://www.nlnetlabs.nl/publications/dnssec_howto/">DNSSEC
        HOWTO</link> (nlnetlabs.nl)</para>
      </listitem>
    </itemizedlist>

    <para>On ISC DHCP:</para>

    <itemizedlist>
      <listitem>
        <para><link
        xlink:href="http://www.madboa.com/geek/dhcp-failover/">High-available
        DHCP with failover</link> (IPv4 only) (Madboa.com)</para>
      </listitem>
    </itemizedlist>
  </section>
</chapter>
