<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="certificates"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title>Certificates and PKI</title>

  <section>
    <title>Why we need it</title>

    <para>Now that some of the basic network services have been installed, it
    is time to look at certificate management.</para>

    <para>Certificates are used to either authenticate people or clients to a
    service, or to support encryption of data sent across the network. For
    small networks, administrators usually create self-signed
    certificates<indexterm>
        <primary>certificate</primary>
      </indexterm>, but the problem with self-signed certificates is that
    every client that wants to communicate with a service using a self-signed
    certificate needs to include this certificate in its trust store.</para>

    <para>What is that you say? Let's give a quick explanation on certificates
    then.</para>

    <section>
      <title>How do certificates work</title>

      <para>Assume there are two parties (Alice and Bob are the two names
      often used in encryption fields) willing to communicate with each other
      over a secured, encrypted channel. They generally need to use an
      encryption key which only those two parties know. Once they have such an
      encryption key, they can use it to communicate with each other
      securely:</para>

      <itemizedlist>
        <listitem>
          <para>because they are the only two with the key, others cannot
          decrypt the information being sent between the two</para>
        </listitem>

        <listitem>
          <para>because no-one else has the key, each of those parties is
          certain that information received from the other one is indeed from
          the other party (as it would otherwise not be properly
          encrypted)</para>
        </listitem>
      </itemizedlist>

      <para>The major difficulty comes from getting a "shared" encryption key
      without having to send it over the (clear) network so that a malicious
      person (Carol or Charles, I'll use the gender-neutral "Chris" ;-) cannot
      obtain it.</para>

      <section>
        <title>Symmetric keys</title>

        <para>Most secure communication uses a symmetric key, often called a
        session key.</para>

        <para>A symmetric key is an encryption key which is used for
        encryption and decryption. In our example of a secure communication,
        the symmetric key is the secret encryption key that the two parties
        (and only those two parties) should have a hold off. Such a symmetric
        key is usually used with an algorithm that is fairly simple (and thus
        has good performance) in regard of encryption and decryption.</para>

        <para>This good performance requirement is needed because it will be
        used to encrypt and decrypt all traffic sent between the two services,
        which can be a fair amount of data. If the encryption and decryption
        algorithms used would be very CPU intensive, the communication would
        be far too slow (or use too many resources on the systems).</para>

        <para>A way to get both parties to know a common, secret key is to
        each use a secret algorithm (or known algorithm with secret data)
        which has the property that, whatever order you use to apply the
        algorithms, the result is always the same. Extremely simple examples
        are addition or multiplication, but far more complex ones exist as
        well. A non-mathematical example would be to add in colored paint to a
        pre-agreed color: if you first add in blue and then red, or first red
        and then blue, the result is always the same.</para>

        <para>Well, in our case (let's use addition), both Alice and Bob have
        such a secret and will exchange the results of their
        algorithms:</para>

        <programlisting>   Alice                 Bob
  "1000"                "1000"
  +7428                 +5879
 = 8428                = 6879
 -------&lt;--exchange-&gt;--------
   6879                  8428
  +7428                 +5879
= 14307               = 14307  &lt;-- the symmetric key</programlisting>

        <para>The number to begin with may be made public (although it is
        safer when its not) because, even with Chris knowing the numbers
        "1000, 8428, 6879", if that person does not know the algorithm (or
        data) used, it will be difficult for him to find out what the common
        secret key will be. Of course, in our example, addition is quite
        simple, but at least it gives the idea on what such key exchange can
        be like.</para>
      </section>

      <section>
        <title>Public and private keys</title>

        <para>What are public/private keys then? Well, the idea behind
        public-key cryptography<indexterm>
            <primary>public-key cryptography</primary>
          </indexterm> is that, unlike a symmetric key, there are now two keys
        in play:</para>

        <itemizedlist>
          <listitem>
            <para>the private key is only known by the target service (say
            Alice)</para>
          </listitem>

          <listitem>
            <para>the public key is known by everyone who wants to communicate
            with the target</para>
          </listitem>
        </itemizedlist>

        <para>The two keys play such that encryption of data happens with the
        public key, but you cannot decrypt that data with the public key. To
        decrypt it, you need the private key. But another aspect is that you
        can encrypt with the private key and decrypt with the public, allowing
        people to verify that data was indeed encrypted by that person (in
        reality this is used to "sign" data, which is to make a checksum of
        the file and then encrypt this checksum).</para>

        <para>In our communication problem from before, this would make it a
        whole lot easier: Bob just takes Alice' public key, encrypts the data
        he wants to send to Alice using the public key, and he's done. Alice
        can do the same with Bob's public key so that two-way communication is
        possible. However, there are a few drawbacks here:</para>

        <itemizedlist>
          <listitem>
            <para>Public-key cryptographic functions are quite resource
            intensive.</para>

            <para>For this reason, they are only used to exchange a symmetric
            key or part of a symmetric key (like the initial number "1000"
            used in our previous example).</para>
          </listitem>

          <listitem>
            <para>A malicious person could create his own public/private key
            pair and tell the world that his public key is the public key of
            Alice. If Bob would want to communicate with Alice but uses Chris'
            public key, he would encrypt the data so that Chris can only read
            it. Chris then decrypts the data, encrypts it with Alice' real
            public key and sends it to Alice. A communication channel between
            Alice and Bob come forth, but Chris is "in the middle" reading
            (and perhaps even manipulating) the data. This is called a
            <emphasis>Man-In-The-Middle</emphasis><indexterm>
                <primary>man-in-the-middle</primary>
              </indexterm> or MITM<indexterm>
                <primary>MITM attack</primary>
              </indexterm> attack.</para>
          </listitem>
        </itemizedlist>

        <para>The second part is the major "downside" of a public key - how
        are you certain that this public key is actually of the target person
        or service you want to communicate with? This is where certificates
        come into play...</para>
      </section>

      <section>
        <title>Certificates</title>

        <para>A certificate is this same public key, together with data that
        identifies who the public/private key belongs to. This certificate
        also has signatures attached that are generated by other certificates.
        The idea is that, if both Alice and Bob know a public key
        (certificate) of a party they <emphasis>both</emphasis> trust (and
        know that this public key is indeed of the trusted party), then Alice
        can send her own certificate, signed by this trusted party, to
        Bob.</para>

        <figure>
          <title>Certificates and CAs in a nutshell</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/04-ca_certificate.png" scalefit="1"
                         width="100%"/>
            </imageobject>
          </mediaobject>
        </figure>

        <para>Bob then validates the signature on this certificate (using the
        public key he has of the trusted party). If the signature indeed pans
        out, then Bob verifies if the certificate isn't in the list of revoked
        certificates (which is managed by the Certificate Authority). If that
        isn't the case, then Bob knows that the certificate he got is indeed
        from Alice (because the trusted party sais so) and of which the
        private key is not known to be lost or stolen (otherwise it would've
        been mentioned in the revocation list).</para>

        <para>A malicious person now has a more difficult task. If a wrong
        certificate is generated, then the trusted party will probably not
        sign it. As a result, Chris cannot "fake" a certificate because both
        Alice and Bob will check the signature of the certificate and the
        certificate revocation list before they agree that it is a valid
        certificate.</para>
      </section>
    </section>

    <section>
      <title>Certificates in organizations</title>

      <para>In a larger organization or network, certificates play an
      important role. Many servers use SSL (or TLS) encryption. In this case,
      the client connects to the server and receives that servers' certificate
      information. The client validates this certificate with the keys he has
      of trusted "authorative" actors. If the certificate is valid, then the
      client knows he is communicating with the correct service. Some magic
      occurs then to generate a session key only the client and the server
      know (if you're interested, search on the internet for "ssl handshake
      pre-master") so they can then use symmetric encryption algorithms for
      the rest of the communication.</para>

      <para>If we were to use self-signed certificates, then all the clients
      should have the public keys of all these systems in their own list of
      trusted keys (this combination is called the <emphasis>trust
      store</emphasis>), which is a nightmare to manage. And if you had to do
      that, why not just keep the symmetric keys then and do not use public
      key infrastructure... Or you could have your clients accept self-signed
      certificates, but then you are vulnerable for MITM attacks.</para>

      <para>This is where good certificate management comes into play. Serious
      organizations need a way to "sign" certificates used in the architecture
      with a single key (or very limited set of keys) and distribute this
      (trusted) public key to all the clients. The trust store of these
      clients is then much smaller.</para>

      <para>The service that signs certificates is called the
      <emphasis>Certificate Authority</emphasis><indexterm>
          <primary>certificate authority</primary>
        </indexterm> or CA<indexterm>
          <primary>CA</primary>
        </indexterm>. Often, a chain of keys is used: a top key called the
      <emphasis>Root CA</emphasis> which is extremely heavily protected and is
      used to sign a small set of subkeys or signing keys. These signing keys
      are then used to sign the certificates. Often, these signing keys have a
      different purpose (keys for signing certificates that will be used for
      code signing, keys for signing certificates that will be used for
      authenticating people or clients, keys for signing certificates that
      will be used for internet-facing services, etc.)</para>

      <section>
        <title>Problems with Certificate Authorities</title>

        <para>On the Internet, many popular CA services exist, like
        CACert.org, Verizon, Geotrust, and more. All these companies try to
        become this "trusted party" that others seek and offer signing
        services: they will sign certificates you create (some of them even
        generate public/private key pairs if you want). These services try to
        protect their own keys and only sign certificates from customers they
        can validate are proper customers (with correct identities).</para>

        <para>Although this seems like a valid model, it does have its
        flaws:</para>

        <itemizedlist>
          <listitem>
            <para>Such popular services are more likely target for hackers and
            crackers. Once their keys are compromised, you should actively
            revoke their public keys from your trust stores. However, that
            also means that all certificates you use for your services that
            are signed by these companies will effectively stop working as
            your clients will not trust the certificates anymore.</para>
          </listitem>

          <listitem>
            <para>These services have a financial incentive to sign
            certificates. If they do not do proper validation of the
            certificate requests they get, they might sign a certificate from
            a malicious person (who is pretending to be a valid
            customer).</para>
          </listitem>

          <listitem>
            <para>The more of these keys that are in your clients' trust
            store, the more chance that a malicious certificate is seen by
            your client as valid.</para>
          </listitem>
        </itemizedlist>

        <para>The latter is important to remember. Assume that your clients'
        truststore has 100 certificates that it "trusts", even though your
        organization only uses a single one. If a malicious user creates a
        certificate that identifies itself as one of your services and gets it
        signed by one of those 100 CAs, then your client will trust the
        connection if it uses this (malicious) certificate (because it is
        signed with one of the trusted keys).</para>
      </section>

      <section>
        <title>Keeping a lid on CAs</title>

        <para>To keep the risk sufficiently low that a malicious certificate
        is being used, you need to find a CA that you trust fully, and keep
        your trust store limited to that CA.</para>

        <para>And who else to trust better than yourself ;-)</para>

        <para>By using management software for certificates internally, many
        important activities can be handled without having to seek for and pay
        a large CA vendor:</para>

        <itemizedlist>
          <listitem>
            <para>You can create your own CA store</para>
          </listitem>

          <listitem>
            <para>You can sign requests of certificate requests that users
            have sent to you</para>
          </listitem>

          <listitem>
            <para>You can revoke certificates (or at least, signatures you
            made on certificates) for end user certificates that you should
            not allow to trust anymore (for instance because they have been
            compromised)</para>
          </listitem>

          <listitem>
            <para>You can have users create a certificate (in case they don't
            have the proper tools on their systems, although I seriously don't
            recommend to generate private and public keys on a remote
            server)</para>
          </listitem>

          <listitem>
            <para>You can have users submit a certificate signing request to
            you for processing, and then download the signed certificate from
            the site</para>
          </listitem>
        </itemizedlist>

        <para>The use of a webbased software allows you to fully isolate the
        service so that the number of attack vectors against the system is
        very limited.</para>
      </section>
    </section>
  </section>

  <section>
    <title>CA Service Software</title>

    <para>As CA management software, we will use the command line interface of
    <command>openssl</command>. Although more user friendly interfaces seem to
    exist, they are either not properly maintained or very difficult to manage
    in the long term. For this reason, we stick with the
    <command>openssl</command> interface.</para>

    <section>
      <title>OpenSSL as CA</title>

      <para>The OpenSSL stack is a very common, well maintained library for
      handling encryption and encryption-related functions, including
      certificate handling. Most, if not all Linux/Unix systems have it
      installed, so you should be good to go.</para>

      <section>
        <title>Setting the defaults</title>

        <para>The default settings for using OpenSSL are stored in the
        /etc/ssl/openssl.cnf file. Below shows a few changes I suggest when
        dealing with CA certificates.</para>

        <programlisting>[CA_default]
dir = ./genficCA
default_days = 7305 # 20 years

[req]
default_bits = 2048</programlisting>
      </section>

      <section>
        <title>Setting up the root CA</title>

        <para>The root CA is the top-level key, which will be "ultimately
        trusted". If you would use an HSM device, this key would be stored in
        the HSM device itself and never leave. But in case this isn't
        possible, you can create a root CA yourself:</para>

        <programlisting># <command>cd /etc/ssl/private</command>
# <command>openssl genrsa -des3 -out root-genfic.key 2048</command></programlisting>

        <para>This generates root-genfic.key, which is the private key and
        will be used as the root key.</para>

        <para>Next, create a certificate from this key. In the example, I'll
        use a 20-year lifespan, but you should check what is the best lifespan
        in your case. The shorter the lifespan, the faster you'll need to
        refresh the key stores within your (entire) organization, which can be
        a costly activity. However, the longer the period, the more time
        malicious persons have to get to the key before you generate a new
        one.</para>

        <programlisting># <command>openssl req -new -x509 -days 7205 -key root-genfic.key -out root-genfic.crt</command>
Country Name (2 letter code) [AU]:<command>BE</command>
State or Province Name (full name) [Some-State]:<command>Antwerp</command>
Locality Name (eg, city) []:<command>Mechelen</command>
Organization Name (eg, company) [Internet Widgits Pty Ltd]:<command>Gentoo Fictional, Inc.</command>
Organizational Unit Name (eg, section) []:
Common Name (e.g. server FQDN or YOUR name) []:<command>GenFic Root CA</command>
Email Address []:</programlisting>

        <para>This provides us with the root-genfic.crt file, which is the
        certificate (public key of the keypair created before, together with
        identity information and key information). If you want to take a look
        at what the certificate contains, use openssl x509:</para>

        <programlisting># <command>openssl x509 -noout -text -in root-genfic.crt</command></programlisting>

        <para>Finally, create the certificate revocation list (which is empty
        for now):</para>

        <programlisting># <command>mkdir genficCA</command>
# <command>touch genficCA/index.txt</command>
# <command>echo 01 &gt; genficCA/crlnumber</command>
# <command>openssl ca -gencrl -crldays 365 -keyfile root-genfic.key -cert root-genfic.crt \
    -out root-genfic.crl</command></programlisting>

        <para>Now put all files in the location(s) as defined in
        openssl.cnf.</para>
      </section>

      <section>
        <title>Multilevel (or hierarchical) certificate authorities</title>

        <para>In many environments, the root key itself isn't used to sign
        "end" user (or system) certificates: a hierarchy is established to
        support a more flexible approach on certificates. Often, this
        hierarchy is to reflect the use of the certificates (end user
        certificates, system certificates) and, if the organization has
        multiple companies, these companies often have an intermediate
        certificate authority. In our example, we'll use a simple hierarchy:
        below the root certificate, we use signing certificates for end users
        and for systems:</para>

        <programlisting>root CA
+- user CA
`- system CA</programlisting>

        <para>The root certificate (which was created earlier) will be stored
        offline (not reachable through the network, and preferably in a shut
        down state or on a HSM device) together with the certificates created
        for the user and system CA's. This is needed in case you need to
        revoke these certificates, since the process of revoking a certificate
        (see later) requires the certificate.</para>

        <para>To support the two additional CA's, edit openssl.cnf
        accordingly. Add sections for each CA you want to support - you can
        copy the "[ CA_default ]" settings and edit the directory and other
        settings where necessary. I use CA_root, CA_user and CA_system to
        identify the different certificate authorities.</para>

        <para>Then, create the keys:</para>

        <programlisting># <command>openssl genrsa -des3 -out user-genfic.key 2048</command>
# <command>openssl genrsa -des3 -out system-genfic.key 2048</command></programlisting>

        <para>Next, create certificate requests. Unlike the root CA, we will
        not sign the certificate request with the same key, but rather with
        the root CA key.</para>

        <programlisting># <command>openssl req -new -days 1095 -key user-genfic.key -out user-genfic.csr</command>
# <command>openssl req -new -days 1109 -key system-genfic.key -out system-genfic.csr</command></programlisting>

        <para>If the command asks for a challenge password, you can leave that
        empty. The purpose of the challenge password is that, if the
        certificate is to be revoked, the challenge password needs to be given
        again as well. This gives some assurance that rogue administrators
        can't revoke certificates that they don't own, but in our case we will
        store the root key offline (rather than a service) so that revocation
        of the certificates requires (physical) access to the keys
        anyhow.</para>

        <para>The .csr files (Certificate Signing Request) contain the public
        key of the keypair generated, as well as identity information. Based
        on the CSR, the root CA will sign and create a certificate:</para>

        <programlisting># <command>openssl ca -name CA_root -days 1095 -extensions v3_ca -out system-genfic.crt \
    -infiles system-genfic.csr</command>
# <command>openssl ca -name CA_root -days 1109 -extensions v3_ca -out user-genfic.crt \
    -infiles user-genfic.csr</command></programlisting>

        <para>You might have noticed I have different validation periods for
        the certificates. This is to support the (plausible) management
        activites that result when certificates are suddenly expired. If the
        organization "forgets" that the certificates expire, their user
        certificates will expire first, and two weeks later the system
        certificates. Not only will this allow the continued servicing of the
        various systems while the user CA certificate is being updated, but
        will also allow the organization to prepare for the system CA update
        in time (since they now have 14 days since they "noticed" that the
        user CA certificate was expired until the system CA certificate
        expires).</para>

        <para>When the certificate signing requests are handled, you will
        notice that the genficCA/newcerts directory contains the two
        certificates. This allows for the CA to revoke the certificates when
        needed.</para>

        <para>Finally, we copy the signed certificates and prepare the
        directory structure for the two certificate authorities as
        well.</para>

        <programlisting># <command>mkdir genficSystemCA</command>
# <command>cd genficSystemCA</command>
# <command>touch index.txt</command>
# <command>echo 01 &gt; serial</command>
# <command>echo 01 &gt; crlnumber</command>
# <command>mkdir newcerts crl private</command>
# <command>mv ../system-genfic.key private/</command></programlisting>
      </section>

      <section>
        <title>Protecting the root CA</title>

        <para>As mentioned before, it is good practice to protect the root CA.
        You can do so by handling the system as a separate, offline system (no
        network connection) although, with the other CAs in place, there is
        little reason for the root CA to be permanently "available". In other
        words, it is fine to move it to some offline medium (you can even
        print it out if you want) and store this in a (very) safe location.
        For instance put it on a flash disk (or tape if you have tape drives)
        and put it in a safe (or better, two flash disks in two safes).</para>
      </section>
    </section>

    <section>
      <title>Daily handling</title>

      <para>With the certificate authority files in place, we can now take
      care of the daily operations involving certificates.</para>

      <section>
        <title>User certificates</title>

        <para>A user certificate is used by a person to identify himself
        towards services. Such certificates can be used to authenticate a user
        for operating system access, but a more common use of user
        certificates is access towards websites: the user has a key (and
        certificate) loaded in the browser (or to which the browser has access
        to, in case the key itself is on a smartcard or other HSM) and sites
        that want the user to identify himself can ask for the user
        certificate.</para>

        <para>A user can create his own key using the following openssl
        command, and its accompanying certificate signing request:</para>

        <programlisting># <command>openssl req -newkey rsa:2048 -keyout amber.key -out amber.req</command></programlisting>

        <para>The signing request (.req) is sent to the certificate authority,
        which then validates and signs the request, generating a signed
        certificate:</para>

        <programlisting># <command>openssl ca -name CA_user -days 396 -out amber.crt -infiles amber.req</command></programlisting>

        <para>This generates a certificate that is valid for 13 months.</para>
      </section>

      <section>
        <title>System certificates</title>

        <para>System certificates are created similarly to the user
        certificates, but depending on the system that uses it, the key might
        not be encrypted (-nodes). Encrypting a private key is a useful
        measure to protect the keys more (especially user keys are best used
        with encryption or on a HSM device with password protection since they
        are in many cases "mobile"), but not all hosts that need a system
        certificate can deal with encrypted keys.</para>

        <programlisting># <command>openssl req -newkey rsa:2048 -nodes -keyout w03443ad.key -out w03443ad.req</command></programlisting>

        <para>It is a good practice to use, as e-mail address, the e-mail
        address of the requestor (or a "shared" e-mail address that is known
        to remain fixed throughout the lifetime of the system). This
        information is used later to send e-mails regarding expiration dates
        or other important news.</para>

        <programlisting># <command>openssl ca -name CA_system -days 3650 -out w03443ad.crt -infiles w03443ad.req</command></programlisting>
      </section>

      <section>
        <title>Listing certificate expirations</title>

        <para>To list the expiration date(s) of the certificates signed by a
        CA, you can iterate over the files in the newcerts location, showing
        the subject and its expiration date:</para>

        <programlisting># <command>openssl x509 -noout -subject -enddate -in 01.pem</command></programlisting>
      </section>

      <section>
        <title>Revoking a certificate</title>

        <para>Suppose a user reports that his or her private key is lost (or
        even worse, compromised).</para>

        <para>First, you need to find this users' (signed) certificate. You
        can look at the index.txt file within the CA directory to find out
        what number the certificate has, and then use this number for the
        revokation:</para>

        <programlisting># <command>grep amber genficUserCA/index.txt</command>
V ... 23    unknown /C=BE/.../CN=Amber McStone/emailAddress=...
# <command>openssl ca -name CA_user -revoke genficUserCA/newcerts/23.pem</command></programlisting>

        <para>As a result, the database is now updated, showing that the
        certificate itself is revoked. Next, you need to publish the new
        certificate revocation list:</para>

        <programlisting># <command>openssl ca -name CA_user -gencrl -out genficUserCA/crl/user-genfic.crl</command></programlisting>

        <para>The resulting certificate revocation list then needs to be
        published where all users can find it.</para>
      </section>
    </section>
  </section>
</chapter>
