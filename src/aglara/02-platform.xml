<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="platform" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title>Platform selection</title>

  <section>
    <title>Gentoo Linux</title>

    <para>Within the reference architecture, we standardize on Gentoo Linux.
    Standardization on a single platform is needed to keep costs sufficiently
    low, but also offers the advantage that you can use solutions specific for
    this platform, rather than having to look for solutions that must support
    a multitude of platforms. Of course, the choice of picking Gentoo Linux
    here might seem weird - why not CentOS (as that has a possible commercial
    backing towards RedHat Enterprise Linux when needed)?</para>

    <itemizedlist>
      <listitem>
        <para>First of all - I'm a Gentoo Linux developer. Its the
        distribution I know the best.</para>

        <para>But in light of our fictional company, it might also be because
        its current (fictional) engineers are all Gentoo Linux developers, or
        because it has ties with regional Gentoo Linux supporting
        services.</para>
      </listitem>

      <listitem>
        <para>The reason to use CentOS (RHEL) could be to have certified
        hosting of certain products which are only supported on RHEL (or
        similar). However, because we will only use free software solutions,
        this requirement is not valid in our case.</para>
      </listitem>

      <listitem>
        <para>Gentoo Linux offers a minimalistic approach on supported
        features. Thanks to a good balance of USE flags, we can install
        servers and services that offer just those services we need, without
        any additional dependencies or features that we will have to disable
        (in order to secure the services) anyhow. This leads to somewhat
        better performance, but also to a saving in storage requirements,
        patching frequency, etc.</para>
      </listitem>

      <listitem>
        <para>Gentoo has a subproject called Gentoo Hardened who strives to
        provide security-improving patches on the base system. This project
        has always been a fore-runner in security mitigation
        strategies.</para>
      </listitem>
    </itemizedlist>

    <para>Of course, because this book is called "A Gentoo Linux Advanced
    Reference Architecture", it would be weird to have it talk about another
    distribution, wouldn't it?</para>

    <para>Now, the selection of Gentoo Linux also has a few challenges up its
    sleeve.</para>

    <itemizedlist>
      <listitem>
        <para>Gentoo Linux is primarily a source-based distribution, which is
        frequently frowned upon in the enterprise market. Weirdly enough, they
        don't find it strange that their development and operational teams
        keep on building frameworks and tools themselves because of lack of
        good tools. This is exactly where Gentoo Linux outshines the others:
        it offers many tools out-of-the-box to support every possible
        requirement.</para>

        <para>To reduce the impact of its source-only stigma, we will be using
        build servers and binhost support for improved manageability.</para>
      </listitem>
    </itemizedlist>

    <para>We will standardize on the x86_64 architecture (or in Gentoo's
    terms, amd64), partially because it is the widest known in the Gentoo
    Linux development community, but also because its hardware is widely
    available and sufficiently cheap. We might invest in ARM in the future as
    well (as it has good potential, better power consumption ratios, etc.) but
    for now, we will focus on x86_64 only.</para>

    <para>That being said, we'll also use the no-multilib approach in Gentoo
    Linux. Systems need to be fully x86_64 driven, partially for
    standardization as well, but also to make debugging easier. The fewer
    special cases you need to think about, the faster you can resolve
    problems. Generally though, this gives little (to no) additinoal advantage
    towards a multilib profile. But as this is a reference architecture, I'll
    stick with this.</para>

    <section>
      <title>Gentoo Hardened</title>

      <para>To increase security of the deployments, all systems will use a
      Gentoo Hardened deployment. Within the Gentoo Linux community, Gentoo
      Hardened is a project that oversees the research, implementation and
      maintenance of security-oriented projects in Gentoo Linux. It focuses on
      delivering viable security strategies for high stability production
      environments and is therefor absolutely suitable for this reference
      architecture.</para>

      <para>Within our scope, we will implement all services on a Gentoo
      Hardened deployment with the following security measures in
      place:</para>

      <itemizedlist>
        <listitem>
          <para>PaX</para>
        </listitem>

        <listitem>
          <para>PIE/PIC/SSP</para>
        </listitem>

        <listitem>
          <para>SELinux as MAC</para>
        </listitem>

        <listitem>
          <para>grSecurity kernel improvements</para>
        </listitem>
      </itemizedlist>

      <section>
        <title>PaX</title>

        <para>The PaX<indexterm>
            <primary>PaX</primary>
          </indexterm> project (part of grSecurity) aims to update the Linux
        kernel with <link
        xlink:href="http://pax.grsecurity.net/docs/pax.txt">defense
        mechanisms</link> against exploitation of software bugs that allow an
        attacker access to the software's address space (memory). By
        exploiting this access, a malicious user could introduce or execute
        arbitrary code, execute existing code without the applications'
        intended behavior, or with different data than expected.</para>

        <para>One of the defence mechanisms introduced is NOEXEC<indexterm>
            <primary>NOEXEC</primary>
          </indexterm>. With this enabled, memory pages of an application
        cannot be marked writeable and executable. So either a memory page
        contains application code, but cannot be modified (kernel enforced),
        or it contains data and cannot be executed (kernel enforced). The
        enforcement methods used are beyond the scope of this book, but are
        described <link
        xlink:href="http://pax.grsecurity.net/docs/noexec.txt">online</link>.
        Enforcing NOEXEC does have potential consequences: some applications
        do not work when PaX enforces this behavior. Because of this, PaX
        allows administrators to toggle the enforcement on a per-binary basis.
        For more information about this, see the Hardened Gentoo PaX
        Quickstart document (see resources at the end of this chapter). Note
        that this also requires PIE/PIC built code (see later).</para>

        <para>Another mechanism used is ASLR<indexterm>
            <primary>ASLR</primary>
          </indexterm>, or Address Space Layout Randomization. This thwarts
        attacks that need advance knowledge of addresses (for instance through
        observation of previous runs). With ASLR enabled, the address space is
        randomized for each application, which makes it much more difficult to
        guess where a certain code (or data) portion is loaded, and as such
        attacks will be much more difficult to execute succesfully. This
        requires the code to be PIE built.</para>

        <para>To enable PaX, you will need to install the hardened-sources
        kernel in Gentoo Linux and configure it according to the instructions
        found on the Hardened Gentoo PaX Quickstart document. You should also
        install <command>paxctl</command><indexterm>
            <primary>paxctl</primary>
          </indexterm>.</para>

        <programlisting># <command>emerge hardened-sources</command>
# <command>emerge paxctl</command></programlisting>
      </section>

      <section>
        <title>PIE/PIC/SSP</title>

        <para>The given abbreviations describe how source code is built into
        binary, executable code.</para>

        <para>PIC<indexterm>
            <primary>PIC</primary>
          </indexterm> (Position Independent Code) is used for shared
        libraries to support the fact that they are loaded in memory
        dynamically (and without prior knowledge to the addresses). Whereas
        older methods use load-time relocation (where address pointers are all
        rewritten the moment the code is loaded in memory), PIC uses a higher
        abstraction of indirection towards data and function references. By
        building shared objects with PIC, relocations in the text segment in
        memory (which contains the application code) are not needed anymore.
        As such, these pages can be marked as non-writeable.</para>

        <para>To find out if you have libraries that still support text
        relocations<indexterm>
            <primary>text relocation</primary>
          </indexterm>, you can install the pax-utils package and scan your
        libraries for text relocations:</para>

        <programlisting># <command>emerge pax-utils</command>
$ <command>scanelf -lpqt</command>
TEXTREL  /opt/Citrix/ICAClient/libctxssl.so</programlisting>

        <para>In the above example, the libctxssl.so file is not built with
        PIC and as such could be more vulnerable to attacks as its
        code-containing memory pages might not be marked as
        non-writeable.</para>

        <para>With PIE<indexterm>
            <primary>PIE</primary>
          </indexterm> (Position Independent Executables) enabled, executables
        are built in a fashion similar to shared objects: their base address
        can be relocated and as such, PaX' ASLR method can be put in effect to
        randomize the address in use. An application binary that is PIE-built
        will show up as a shared object file rather than an executable file
        when checking its ELF header</para>

        <programlisting>$ <command>readelf -h /bin/ls | grep Type</command>
  Type:            DYN (Shared object file)

$ <command>readelf -h /opt/Citrix/ICAClient/wfcmgr.bin | grep Type</command>
  Type:            EXEC (Executable file)</programlisting>

        <para>SSP<indexterm>
            <primary>SSP</primary>
          </indexterm> finally stands for Stack Smashing Protection. Its
        purpose is to add in additional buffers after memory allocations (for
        variables and such) which contain a cryptographic marker (often called
        the canary). When an overflow occurs, this marker is also overwritten
        (after all, that's how overflows work). When a function would return,
        this marker is first checked to see if it is still valid. If not, then
        an overflow has occurred and the application is stopped
        abruptly.</para>
      </section>

      <section>
        <title>SELinux as MAC</title>

        <para>With a MAC<indexterm>
            <primary>MAC</primary>
          </indexterm> (Mandatory Access Control<indexterm>
            <primary>Mandatory Access Control</primary>
          </indexterm>), the system administrator can control which accesses
        are allowed and which not, and can enforce that the user cannot
        override this. Regular access patterns in Linux are discretionary, so
        the user can define this himself. In this book, we will use
        SELinux<indexterm>
            <primary>SELinux</primary>
          </indexterm> as the MAC system. Another supported MAC in Gentoo
        Hardened is grSecurity's RBAC model.</para>

        <para>Installing and configuring Hardened Gentoo with SELinux is
        described in the Gentoo SELinux handbook. It is seriously recommended
        to read through this resource a few times, as SELinux is not just
        about enabling a feature - it is a change in the security model and
        requires experience with it.</para>

        <para>We will use the SELinux strict policy (so no unconfined domains)
        for regular services, or MCS (without unconfined domains) when we want
        to use the multi-tenancy support.</para>

        <programlisting>$ <command>id -Z</command>
staff_u:staff_r:staff_t

# <command>sestatus</command>
SELinux status:                 enabled
SELinuxfs mount:                /selinux
SELinux root directory:         /etc/selinux
Loaded policy name:             strict
Current mode:                   enforcing
Mode from config file:          enforcing
Policy MLS status:              disabled
Policy deny_unknown status:     denied
Max kernel policy version:      26</programlisting>
      </section>

      <section>
        <title>grSecurity kernel improvements</title>

        <para>Next to the previously mentioned grSecurity updates, grSecurity
        also adds in additional kernel protection measures.</para>

        <para>This includes additional hardening on chroot jails (to make it a
        lot more difficult to break out of a chroot) and file system abuse
        (like getting information from pseudo-filesystems to improve
        attacks).</para>

        <para>For more information on enabling grSecurity, see the Gentoo
        grSecurity v2 Guide.</para>
      </section>

      <section>
        <title>Security benchmark</title>

        <para>As mentioned earlier, we will try to provide security benchmarks
        for the services that we configure. The security benchmark for Gentoo
        Linux currently contains checks for</para>

        <itemizedlist>
          <listitem>
            <para>mount options</para>
          </listitem>

          <listitem>
            <para>kernel configuration options (including those for PaX and
            grSecurity)</para>
          </listitem>

          <listitem>
            <para>SSH daemon configuration</para>
          </listitem>

          <listitem>
            <para>general system settings and mandatory USE flags</para>
          </listitem>

          <listitem>
            <para>state of unsecure services</para>
          </listitem>

          <listitem>
            <para>bootloader configuration protection</para>
          </listitem>

          <listitem>
            <para>authorization settings</para>
          </listitem>

          <listitem>
            <para>file and directory privileges</para>
          </listitem>
        </itemizedlist>

        <para>I am still planning on extending the benchmarks further and
        further, but also to provide proper ways to automatically enforce
        these settings.</para>

        <para>To verify the state of your system against the given benchmark,
        we first generate the necessary output (as the test is not allowed to
        execute commands itself, so we need to prepare the output
        first).</para>

        <programlisting># <command>mkdir /var/tmp/genoval_output</command>
# <command>export GENOVAL_SCRIPTOUTPUTDIR=/var/tmp/genoval_output</command>
# <command>emerge --info --verbose &gt; ${GENOVAL_SCRIPTOUTPUTDIR}/emerge-info-verbose</command>
# <command>zcat /proc/config.gz &gt; ${GENOVAL_SCRIPTOUTPUTDIR}/kernel-config</command></programlisting>

        <para>Next, you can run the tests and see if your system is configured
        properly:</para>

        <programlisting># <command>oscap xccdf eval --profile Gentoo-Default scap-gentoo-xccdf.xml</command></programlisting>

        <para>You can generate an HTML report too</para>

        <programlisting># <command>oscap xccdf eval --profile Gentoo-Default --results xccdf-results.xml --report report.html scap-gentoo-xccdf.xml</command></programlisting>
      </section>
    </section>

    <section>
      <title>Virtualized platforms</title>

      <para>When possible, we will use virtualization. This offers a hardware
      abstraction so that we can move guests from one hardware platform to
      another without having too much impact on the loaded drivers. It also
      supports better availability models (fast recovery when hardware fails)
      and improved resource usage (which benefits our cost efficiency
      again).</para>

      <para>As virtualization platform, we will choose KVM as it offers many
      interesting features (both for development as well as larger enterprise
      usability).</para>

      <section>
        <title>Hypervisor kernel configuration</title>

        <para>A hypervisor<indexterm>
            <primary>hypervisor</primary>
          </indexterm> is the general term given to the host operating system
        that offers virtualization services, so in effect is running the
        virtual guests as processes (or groups of processes). In case of
        KVM<indexterm>
            <primary>KVM</primary>
          </indexterm>, this means that the Linux kernel will be configured
        with KVM enabled, but also with the proper virtualization
        improvements. Below you can find a subset of kernel configuration
        settings that can be used as a base for the configuration:</para>

        <programlisting># <command>zgrep -E '(KVM|VIRT)' /proc/config.gz</command>
# CONFIG_PARAVIRT_GUEST is not set
CONFIG_VIRT_TO_BUS=y
CONFIG_VIRTIO_BLK=m
CONFIG_VIRTIO_NET=m
# CONFIG_VIRTIO_CONSOLE is not set
# CONFIG_HW_RANDOM_VIRTIO is not set
# CONFIG_FB_VIRTUAL is not set
# CONFIG_SND_VIRTUOSO is not set
CONFIG_VIRTIO=m
CONFIG_VIRTIO_RING=m
# CONFIG_VIRTIO_PCI is not set
CONFIG_VIRTIO_BALLOON=m
CONFIG_VIRT_DRIVERS=y
# CONFIG_DEBUG_VIRTUAL is not set
CONFIG_GRKERNSEC_HARDENED_VIRTUALIZATION=y
CONFIG_HAVE_KVM=y
CONFIG_HAVE_KVM_IRQCHIP=y
CONFIG_HAVE_KVM_EVENTFD=y
CONFIG_KVM_APIC_ARCHITECTURE=y
CONFIG_KVM_MMIO=y
CONFIG_KVM_ASYNC_PF=y
CONFIG_VIRTUALIZATION=y
CONFIG_KVM=m
CONFIG_KVM_INTEL=m
# CONFIG_KVM_AMD is not set</programlisting>

        <para>Make sure that your hardware systems support hardware-assisted
        virtualization. For Intel processors, this means that vmx must be
        available; on AMD processors, this is svm:</para>

        <programlisting># <command>egrep '(vmx|svm)' /proc/cpuinfo | head -1</command>
flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat \
                  pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx \
                  rdtscp lm constant_tsc arch_perfmon pebs bts rep_good nopl \
                  xtopology nonstop_tsc aperfmperf pni dtes64 monitor ds_cpl <emphasis>vmx</emphasis> \
                  est tm2 ssse3 cx16 xtpr pdcm sse4_1 sse4_2 popcnt lahf_lm ida \
                  arat dts tpr_shadow vnmi flexpriority ept vpid</programlisting>
      </section>

      <section>
        <title>Software packages</title>

        <para>To build up the hypervisor, you first need to install
        qemu-kvm<indexterm>
            <primary>qemu-kvm</primary>
          </indexterm>. This is the base platform under which the guests will
        run and supports all possible features you need in a virtualized
        environment.</para>

        <programlisting># <command>emerge qemu-kvm</command></programlisting>

        <para>Next to qemu-kvm, you probably want to install a front-end
        toolchain. If not, you will need to launch images command-line driven,
        which can be quite a hassle to manage:</para>

        <programlisting># <command>qemu-system-x86_64 --enable-kvm -gdb tcp::1237 -vnc 127.0.0.1:3 \
     -net nic,model=virtio,macaddr=00:11:22:33:44:b1,vlan=0 \
     -net vde,vlan=0 -drive file=/srv/virt/gentoo/test.img,if=virtio,boot=on \
     -usb -usbdevice tablet -smp 4 -cpu kvm64 -k nl-be -m 1536</command></programlisting>

        <para>Same for managing the image files on which they would
        run:</para>

        <programlisting># <command>qemu-img create -f qcow2 test.img 50G</command></programlisting>

        <para>Although this is all very feasible (and with some scripting
        assistance can even be manageable for smaller-scale deployments) you
        will soon look for frameworks that assist you in the configuration and
        management of your virtual environment. There are a couple of these
        available in Gentoo.</para>

        <para>The first one is <package>app-emulation/libvirt</package> and is
        RedHat's virtualization management platform. The hypervisor systems
        run the libvirt daemon which manages the virtual guests as well as
        storage and other settings, and the administrator remotely connects to
        the various hypervisor systems through the
        <package>app-emulation/virt-manager</package> application. Because of
        its support by RedHat, it is constantly growing in features and is
        well supported, but to quickly capture the advancements made by KVM in
        the hypervisor, you might still need to do a lot of things
        manually.</para>

        <para>Another one that is gaining momentum is
        <package>app-emulation/ganeti</package> and is backed by Google. It is
        foremost a command-line driven method but is well capable of handling
        dozens and dozens of hypervisor systems. </para>
      </section>

      <section>
        <title>Simple guests</title>

        <para>When working with simple guests, you can quickly create new
        systems by starting from a basic predefined installation. You create a
        qemu img, boot it to install Gentoo Linux on it, then shut it down and
        use that image as a master template for newly created images.</para>

        <programlisting># <command>qemu-img create -f qcow2 test.img 50G</command>
# <command>qemu-system-x86_64 --enable-kvm -gdb tcp::1237 -vnc 127.0.0.1:3 \
     -net nic,model=virtio,macaddr=00:11:22:33:44:b1,vlan=0 \
     -net vde,vlan=0 -drive file=/srv/virt/gentoo/test.img,if=virtio,boot=on \
     -usb -usbdevice tablet -smp 4 -cpu kvm64 -k nl-be -m 1536</command></programlisting>

        <para>I never said the command would be easy ;-) Luckily, there are
        libraries and tools that simplify the management of KVM-based guests.
        I will discuss those later. Below are a few interesting commands for
        converting images: the first one changes from the copy-on-write format
        to a raw format (which is better performance-wise), the second one
        increases the size of an image with 20 gigabytes.</para>

        <programlisting># <command>qemu-img convert -f raw test.img guest1.img</command>
# <command>qemu-img resize onefile.img +20G</command></programlisting>
      </section>
    </section>
  </section>

  <section>
    <title>Resources</title>

    <para>For more information about the topics in this chapter, you can
    divulge yourself in the information available at the following
    resources...</para>

    <para>Gentoo Hardened:</para>

    <itemizedlist>
      <listitem>
        <para><link
        xlink:href="http://www.gentoo.org/proj/en/hardened/pax-quickstart.xml">Hardened
        Gentoo PaX Quickstart</link></para>
      </listitem>

      <listitem>
        <para><link
        xlink:href="http://eli.thegreenplace.net/2011/11/03/position-independent-code-pic-in-shared-libraries/">Position
        Independent Code</link> in shared libraries</para>
      </listitem>

      <listitem>
        <para><link
        xlink:href="http://www.gentoo.org/proj/en/hardened/pic-guide.xml">Introduction
        to Position Independent Code</link> (Gentoo Linux)</para>
      </listitem>

      <listitem>
        <para><link
        xlink:href="http://blog.fpmurphy.com/2008/06/position-independent-executables.html">Position
        Independent Executables</link></para>
      </listitem>

      <listitem>
        <para><link
        xlink:href="http://www.gentoo.org/proj/en/hardened/selinux/selinux-handbook.xml">Gentoo
        SELinux Handbook</link> (Gentoo Linux)</para>
      </listitem>

      <listitem>
        <para><link
        xlink:href="http://www.gentoo.org/proj/en/hardened/grsecurity.xml">Gentoo
        grSecurity v2 Guide</link> (Gentoo Linux)</para>
      </listitem>

      <listitem>
        <para><link
        xlink:href="http://dev.gentoo.org/~swift/docs/security_benchmarks/">Security
        benchmarks</link></para>
      </listitem>
    </itemizedlist>

    <para>KVM (virtualization):</para>

    <itemizedlist>
      <listitem>
        <para/>
      </listitem>
    </itemizedlist>
  </section>
</chapter>
