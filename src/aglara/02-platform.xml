<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="platform" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title>Platform selection</title>

  <section>
    <title>Gentoo Linux</title>

    <para>Within the reference architecture, we standardize on Gentoo Linux.
    Standardization on a single platform allows organizations to keep the cost
    sufficiently low, but also offers the advantage that you can use solutions
    specific for the platform, rather than having to look for solutions that
    must support a multitude of platforms. Of course, the choice of picking
    Gentoo Linux here might seem weird - why not CentOS (as that has a
    possible commercial backing towards RedHat Enterprise Linux when
    needed)?</para>

    <itemizedlist>
      <listitem>
        <para>First of all - I'm a Gentoo Linux developer. Its the
        distribution I know the best.</para>

        <para>But in light of a (fictional) company, it might also be because
        its current (fictional) engineers are all Gentoo Linux developers, or
        because it has ties with regional Gentoo Linux supporting services. In
        light of many organizations, when there is choice between Linux
        distributions, one thing to consider is which distribution your
        engineers are most likely to work with. I know, asking them will
        probably result in some heavy fighting to see which distribution is
        best (perhaps you can use the <link
        xlink:href="https://en.wikipedia.org/wiki/Condorcet_method">Condorcet
        method</link> to find the best selection), but picking a distribution
        your engineers are less eager to support will result in bad
        administration anyhow.</para>
      </listitem>

      <listitem>
        <para>The reason to use CentOS (RHEL) could be to have certified
        hosting of certain products which are only supported on RHEL (or
        similar). However, because we will only use free software solutions,
        this is no requirement for our case. But it is understandable that
        companies that do run propriatary software choose a distribution that
        is supported by their vendors.</para>
      </listitem>

      <listitem>
        <para>Gentoo Linux offers a fairly flexible approach on supported
        features. Thanks to a good balance of USE flags, we can install
        servers and services that offer just those services we need, without
        any additional dependencies or features that we will have to disable
        (in order to secure the services) anyhow. This leads to somewhat
        better performance, but also to a saving in storage requirements,
        patching frequency, etc. Gentoo is also quite fast in adopting new
        technologies, which might help the business stand out against the
        other competitors.</para>
      </listitem>

      <listitem>
        <para>Gentoo uses rolling upgrades. That might not seem like a good
        way in enterprises, but allow me to convince you - it is. If an
        organization is doing things right, it is already distributing and
        rolling out patches and minor upgrades regularly. With Gentoo, this
        process is a bit more intrusive (as it might contain larger changes as
        well) but because the administrators are used to it, it is very much
        under control. As a result, whereas other organizations have to
        schedule large (expensive and time-consuming) upgrades every 3 to 5
        years, Gentoo just moves along...</para>
      </listitem>

      <listitem>
        <para>Gentoo has a subproject called Gentoo Hardened who strives to
        provide, implement and support security-improving patches on the base
        system. This project has always been a fore-runner in security-related
        risk mitigation strategies.</para>
      </listitem>
    </itemizedlist>

    <para>Of course, because this book is called "A Gentoo Linux Advanced
    Reference Architecture", it would be weird to have it talk about another
    distribution, wouldn't it?</para>

    <para>Now, the selection of Gentoo Linux also has a few challenges up its
    sleeve.</para>

    <itemizedlist>
      <listitem>
        <para>Gentoo Linux is primarily a source-based distribution, which is
        frequently frowned upon in the enterprise market. Weirdly enough, they
        don't find it strange that their development and operational teams
        keep on building frameworks and tools themselves because of lack of
        good tools. This is exactly where Gentoo Linux outshines the others:
        it offers many tools out-of-the-box to support every possible
        requirement.</para>

        <para>To reduce the impact of its source-only stigma, I will dedicate
        a chapter in this book on the use of build servers and binhost support
        for improved manageability.</para>
      </listitem>

      <listitem>
        <para>Because of its source-based nature, it also provides all the
        tools for malicious users to build exploits on the server
        itself.</para>

        <para>In my opinion, it is fairly easy to hide the compiler or at
        least have some group-based access control on it. But regardless of
        that - the moment a malicious user has (shell) access to your system,
        you're screwed anyhow. It is fairly easy to transfer files (even full
        applications) towards the system then.</para>

        <para>To reduce possible impact here, we will be using a Mandatory
        Access Control system which isolates processes and even users,
        confining them to just what they need to get their job done.</para>
      </listitem>
    </itemizedlist>

    <para>We will standardize on the x86_64 architecture (amd64), partially
    because it is the widest known in the Gentoo Linux development community,
    but also because its hardware is widely available and sufficiently cheap.
    It is also a processor architecture that is constantly evolving and has
    many vendors working on it (less monopolizing strategies) which makes it a
    better platform for consumers in my opinion.</para>

    <para>That being said, we'll also use the no-multilib approach in Gentoo
    Linux. Systems need to be fully x86_64 driven, partially for
    standardization as well, but also to make debugging easier. The fewer
    special cases you need to think about, the faster you can resolve
    problems. Generally though, this gives little (to no) additional advantage
    towards a multilib profile. But as this is a reference architecture, I'll
    stick with this.</para>

    <section>
      <title>Gentoo Hardened</title>

      <para>To increase security of the deployments, all systems in this
      reference architecture will use a Gentoo Hardened deployment. Within the
      Gentoo Linux community, Gentoo Hardened is a project that oversees the
      research, implementation and maintenance of security-oriented projects
      in Gentoo Linux. It focuses on delivering viable security strategies for
      high stability production environments and is therefor absolutely
      suitable for this reference architecture.</para>

      <para>Within our scope, we will implement all services on a Gentoo
      Hardened deployment with the following security measures in
      place:</para>

      <itemizedlist>
        <listitem>
          <para>PaX</para>
        </listitem>

        <listitem>
          <para>PIE/PIC/SSP</para>
        </listitem>

        <listitem>
          <para>SELinux as MAC</para>
        </listitem>

        <listitem>
          <para>grSecurity kernel improvements</para>
        </listitem>
      </itemizedlist>

      <para>The installation of a Gentoo Hardened system is similar to a
      regular Gentoo Linux one. You can find all necessary information on the
      Gentoo Hardened project page. Later, we'll describe how to use images of
      a (succesful) installation for seeding new servers and systems.</para>

      <section>
        <title>PaX</title>

        <para>The PaX<indexterm>
            <primary>PaX</primary>
          </indexterm> project (part of grSecurity) aims to update the Linux
        kernel with <link
        xlink:href="http://pax.grsecurity.net/docs/pax.txt">defense
        mechanisms</link> against exploitation of software bugs that allow an
        attacker access to the software's address space (memory). By
        exploiting this access, a malicious user could introduce or execute
        arbitrary code, execute existing code without the applications'
        intended behavior, or with different data than expected.</para>

        <para>One of the defence mechanisms introduced is NOEXEC<indexterm>
            <primary>NOEXEC</primary>
          </indexterm>. With this enabled, memory pages of an application
        cannot be marked writeable and executable. So either a memory page
        contains application code, but cannot be modified (kernel enforced),
        or it contains data and cannot be executed (kernel enforced). The
        enforcement methods used are beyond the scope of this book, but are
        described <link
        xlink:href="http://pax.grsecurity.net/docs/noexec.txt">online</link>.
        Enforcing NOEXEC does have potential consequences: some applications
        do not work when PaX enforces this behavior. Because of this, PaX
        allows administrators to toggle the enforcement on a per-binary basis.
        For more information about this, see the Hardened Gentoo PaX
        Quickstart document (see resources at the end of this chapter). Note
        that this also requires PIE/PIC built code (see later).</para>

        <para>Another mechanism used is ASLR<indexterm>
            <primary>ASLR</primary>
          </indexterm>, or Address Space Layout Randomization. This thwarts
        attacks that need advance knowledge of addresses (for instance through
        observation of previous runs). With ASLR enabled, the address space is
        randomized for each application, which makes it much more difficult to
        guess where a certain code (or data) portion is loaded, and as such
        attacks will be much more difficult to execute succesfully. This
        requires the code to be PIE built.</para>

        <para>To enable PaX, you will need to install the hardened-sources
        kernel in Gentoo Linux and configure it according to the instructions
        found on the Hardened Gentoo PaX Quickstart document. You should also
        install <command>paxctl</command><indexterm>
            <primary>paxctl</primary>
          </indexterm>.</para>

        <programlisting># <command>emerge hardened-sources</command>
# <command>emerge paxctl</command></programlisting>
      </section>

      <section>
        <title>PIE/PIC/SSP</title>

        <para>The given abbreviations describe how source code is built into
        binary, executable code.</para>

        <para>PIC<indexterm>
            <primary>PIC</primary>
          </indexterm> (Position Independent Code) is used for shared
        libraries to support the fact that they are loaded in memory
        dynamically (and without prior knowledge to the addresses). Whereas
        older methods use load-time relocation (where address pointers are all
        rewritten the moment the code is loaded in memory), PIC uses a higher
        abstraction of indirection towards data and function references. By
        building shared objects with PIC, relocations in the text segment in
        memory (which contains the application code) are not needed anymore.
        As such, these pages can be marked as non-writeable.</para>

        <para>To find out if you have libraries that still support text
        relocations<indexterm>
            <primary>text relocation</primary>
          </indexterm>, you can install the pax-utils package and scan your
        libraries for text relocations:</para>

        <programlisting># <command>emerge pax-utils</command>
$ <command>scanelf -lpqt</command>
TEXTREL  /opt/Citrix/ICAClient/libctxssl.so</programlisting>

        <para>In the above example, the libctxssl.so file is not built with
        PIC and as such could be more vulnerable to attacks as its
        code-containing memory pages might not be marked as
        non-writeable.</para>

        <para>With PIE<indexterm>
            <primary>PIE</primary>
          </indexterm> (Position Independent Executables) enabled, executables
        are built in a fashion similar to shared objects: their base address
        can be relocated and as such, PaX' ASLR method can be put in effect to
        randomize the address in use. An application binary that is PIE-built
        will show up as a shared object file rather than an executable file
        when checking its ELF header</para>

        <programlisting>$ <command>readelf -h /bin/ls | grep Type</command>
  Type:            DYN (Shared object file)

$ <command>readelf -h /opt/Citrix/ICAClient/wfcmgr.bin | grep Type</command>
  Type:            EXEC (Executable file)</programlisting>

        <para>SSP<indexterm>
            <primary>SSP</primary>
          </indexterm> finally stands for Stack Smashing Protection. Its
        purpose is to add in additional buffers after memory allocations (for
        variables and such) which contain a cryptographic marker (often called
        the canary). When an overflow occurs, this marker is also overwritten
        (after all, that's how overflows work). When a function would return,
        this marker is first checked to see if it is still valid. If not, then
        an overflow has occurred and the application is stopped
        abruptly.</para>
      </section>

      <section>
        <title>Checking PaX and PIE/PIC/SSP results</title>

        <para>If you want to verify the state of your system after applying
        the security measures identified earlier, install paxtest and run it.
        The application supports two modes: kiddie and blackhat. The blackhat
        test gives the worst-case scenario back whereas the kiddie-mode runs
        tests that are more like the ones script-kiddies would run. The
        paxtest application simulates certain attacks and presents plausible
        results to the reader.</para>

        <para>A full explanation on the tests ran can be found in the
        <filename>/usr/share/doc/paxtest-*/README</filename> file.</para>

        <programlisting># <command>emerge paxtest</command>
# <command>paxtest blackhat</command>

PaXtest - Copyright(c) 2003,2004 by Peter Busser &lt;peter@adamantix.org&gt;
Released under the GNU Public Licence version 2 or later

Writing output to paxtest.log
It may take a while for the tests to complete
Test results:
PaXtest - Copyright(c) 2003,2004 by Peter Busser &lt;peter@adamantix.org&gt;
Released under the GNU Public Licence version 2 or later

Mode: blackhat
Linux hpl 3.1.6-hardened #1 SMP PREEMPT Tue Dec 27 13:49:05 CET 2011 x86_64 Intel(R) Core(TM) i5 CPU M 430 @ 2.27GHz GenuineIntel GNU/Linux

Executable anonymous mapping             : Killed
Executable bss                           : Killed
Executable data                          : Killed
Executable heap                          : Killed
Executable stack                         : Killed
Executable shared library bss            : Killed
Executable shared library data           : Killed
...
Writable text segments                   : Killed
</programlisting>

        <para>These tests will try to write data and then execute it. The
        tests do this in different locations to verify if the memory
        protection measures are working. Killed means that it works as the
        attempt is stopped.</para>

        <programlisting>Executable anonymous mapping (mprotect)  : Killed
Executable bss (mprotect)                : Killed
Executable data (mprotect)               : Killed
Executable heap (mprotect)               : Killed
Executable stack (mprotect)              : Killed
Executable shared library bss (mprotect) : Killed
Executable shared library data (mprotect): Killed
</programlisting>

        <para>These are virtually the same tests as before, but now the
        application first tries to reset or change the protection bits on the
        pages using mprotect.</para>

        <programlisting>Anonymous mapping randomisation test     : 33 bits (guessed)
Heap randomisation test (ET_EXEC)        : 13 bits (guessed)
Heap randomisation test (PIE)            : 40 bits (guessed)
Main executable randomisation (ET_EXEC)  : No randomisation
Main executable randomisation (PIE)      : 32 bits (guessed)
Shared library randomisation test        : 33 bits (guessed)
Stack randomisation test (SEGMEXEC)      : 40 bits (guessed)
Stack randomisation test (PAGEEXEC)      : 40 bits (guessed)
</programlisting>

        <para>The randomisation tests try to find out which level of
        randomisation is put in place. Although randomisation by itself does
        not offer protection, it obscures the view malicious users have on the
        memory structures. The higher the randomisation, the better. On Gentoo
        Hardened, (almost) all binaries are PIE.</para>

        <programlisting>Return to function (strcpy)              : paxtest: return address contains a NULL byte.
Return to function (memcpy)              : Vulnerable
Return to function (strcpy, PIE)         : paxtest: return address contains a NULL byte.
Return to function (memcpy, PIE)         : Vulnerable
</programlisting>

        <para>These types of attacks are very difficult to thwart by kernel
        protection measures only. The author of the paxtest application has
        put those in because he can, even though he knows PaX does not protect
        against them. In effect, he tries to show users that PaX is not an
        all-safe method and that additional security layers are still
        important.</para>
      </section>

      <section>
        <title>SELinux as MAC</title>

        <para>With a MAC<indexterm>
            <primary>MAC</primary>
          </indexterm> (Mandatory Access Control<indexterm>
            <primary>Mandatory Access Control</primary>
          </indexterm>), the system administrator can control which accesses
        are allowed and which not, and can enforce that the user cannot
        override this. Regular access patterns in Linux are discretionary, so
        the user can define this himself. In this book, we will use
        SELinux<indexterm>
            <primary>SELinux</primary>
          </indexterm> as the MAC system. Another supported MAC in Gentoo
        Hardened is grSecurity's RBAC model.</para>

        <para>Installing and configuring Hardened Gentoo with SELinux is
        described in the Gentoo SELinux handbook. It is seriously recommended
        to read through this resource a few times, as SELinux is not just
        about enabling a feature - it is a change in the security model and
        requires experience with it.</para>

        <para>We will use the SELinux strict policy (so no unconfined domains)
        for regular services, or MCS (without unconfined domains) when we want
        to use the multi-tenancy support.</para>

        <programlisting>$ <command>id -Z</command>
staff_u:staff_r:staff_t

# <command>sestatus</command>
SELinux status:                 enabled
SELinuxfs mount:                /selinux
SELinux root directory:         /etc/selinux
Loaded policy name:             strict
Current mode:                   enforcing
Mode from config file:          enforcing
Policy MLS status:              disabled
Policy deny_unknown status:     denied
Max kernel policy version:      26</programlisting>
      </section>

      <section>
        <title>grSecurity kernel improvements</title>

        <para>Next to the previously mentioned grSecurity updates, grSecurity
        also adds in additional kernel protection measures. This includes
        additional hardening on chroot jails (to make it a lot more difficult
        to break out of a chroot) and file system abuse (like getting
        information from pseudo-filesystems to improve attacks).</para>

        <para>For more information on enabling grSecurity, see the Gentoo
        grSecurity v2 Guide.</para>
      </section>
    </section>

    <section>
      <title>Installation choices</title>

      <para>During the initial installation of Gentoo, a few choices will
      already need to be made.</para>

      <section>
        <title>Partitioning and LVM</title>

        <para>In our architecture, we will be using directly attached storage
        (so no SAN nor NAS for every possible file system) and deal with the
        consequences of having distributed storage differently. One of the
        methods we will be using is to use LVM wherever we can, including for
        the root file system. I do recommend that the internal storage is
        somewhat protected against disk failure through RAID. Although I am a
        proponent of RAID1, <link
        xlink:href="http://assets.en.oreilly.com/1/event/27/Linux%20Filesystem%20Performance%20for%20Databases%20Presentation.pdf">tests</link>
        have shown that RAID5 performs equally well.</para>

        <para>We will use a non-LVM partition (RAID1 protected) for the /boot
        location, and use LVM volumes for the rest. We will also define
        different volume groups for system versus data.</para>

        <programlisting># <command>pvcreate /dev/md1</command>
# <command>vgcreate vg_system /dev/md1</command>
# <command>lvcreate -l 20G -n lv_root vg_system</command>
# <command>lvcreate -l 10G -n lv_home vg_system</command></programlisting>

        <para>Through this approach, the root file system will be hosted on
        /dev/mapper/vg_system-lv_root and as such be expandable (if necessary)
        as well as protected by the underlying RAID system. If you keep enough
        free space in the volume group, you can work with snapshots to support
        flexible backup methods.</para>

        <para>Needless to say, you will need to boot with an initramfs.</para>

        <programlisting># <command>genkernel --install --lvm initramfs</command></programlisting>

        <para>Don't forget to update the bootloader configuration.</para>
      </section>

      <section>
        <title>The /boot location</title>

        <para>I tend to keep my /boot location pretty "big" considering what
        other users think is needed: 1 Gbyte. Although the kernel and
        initramfs (plus boot loader files) are only a few megabytes, I often
        place a rescue environment in it (such as a <link
        xlink:href="http://www.sysresccd.org">sysresccd</link>) so that I can
        recover even when initramfs is unable to. It also allows me to install
        additional verification tools like memtest and the like.</para>
      </section>

      <section>
        <title>System logger</title>

        <para>For system logging, we will use syslog-ng, a well-supported
        advanced logging daemon.</para>

        <programlisting># <command>emerge syslog-ng</command></programlisting>
      </section>

      <section>
        <title>Network settings</title>

        <para>We will be using IPv6 exclusively in this architecture, but for
        some applications, we still need to support IPv4. When this is the
        case, we will try to only use 127.0.0.1.</para>

        <para>To setup a system with IPv6, first set the /etc/conf.d/net file
        accordingly. For instance, for one of our name servers (which we'll
        describe later):</para>

        <programlisting># <command>cat /etc/conf.d/net</command>
config_eth0="2001:db8:81:21::ac:98ad:5fe1/64";</programlisting>

        <para>Our hostname will be set in a fully qualified way (primarily for
        use by puppet later):</para>

        <programlisting># <command>cat /etc/conf.d/hostname</command>
hostname="ns.genfic.com"

# <command>cat /etc/hosts</command>
::1                             localhost
2001:db8:81:21::ac:98ad:5fe1  ns.genfic.com  ns</programlisting>

        <para>As a quick hint, if you want to ping hosts using IPv6, use
        <command>ping6</command>.</para>
      </section>
    </section>
  </section>

  <section>
    <title>Virtualization using KVM</title>

    <para>When possible, we will use virtualization. As virtualization
    platform, we will choose KVM as it offers many interesting features (both
    for development as well as larger enterprise usability) and is quite
    popular in the Linux development (and user) community. Other
    virtualization techniques that can be used are Xen or Virtualbox. Within
    Gentoo Linux, KVM is a popular and much-used virtualization
    technology.</para>

    <section>
      <title>Why virtualize</title>

      <para>Virtualization has been around for quite some time. Early
      mainframe installations already had a sort of isolation that is not far
      off from virtualization nowadays. However, virtualization is not just a
      mainframe concept anymore - most larger enterprises are already fully
      working on the virtualization of their stacks. Products like
      VMWare<indexterm>
          <primary>VMWare</primary>
        </indexterm> have popularized virtualization in the enterprise, and
      other hypervisors like KVM, VirtualBox, Xen and more are trying to get a
      piece of the cacke.</para>

      <para>To help administrators manage the virtual guests that are running
      on dozens of hosts, frameworks have emerged that lift some of the
      management tasks to a higher level. These frameworks offer automated
      generation of new guests, simplified configuration of the instances,
      remote management of guests. Some of them even support maintenance
      activities, such as moving guests from one host to another, or monitor
      the resource consumption of guests to find a good balance between
      running guests and available hosts.</para>

      <para>In Gentoo, many of these virtualization frameworks are
      supported.</para>

      <para>The first one is <package>app-emulation/libvirt</package> and is
      RedHat's virtualization management platform. The hypervisor systems run
      the libvirt daemon which manages the virtual guests as well as storage
      and other settings, and the administrator remotely connects to the
      various hypervisor systems through the
      <package>app-emulation/virt-manager</package> application. It has
      support for SELinux through its s(ecure)Virt(ualization) feature. To do
      so, it does require the MCS SELinux policy. Libvirt is also being used
      by many other frameworks (like oVirt, Archipel, Abiquo and more).</para>

      <para>Another one that is gaining momentum is
      <package>app-emulation/ganeti</package> and is backed by Google. It is
      foremost a command-line driven method but is well capable of handling
      dozens and dozens of hypervisor systems. It supports simplified
      fail-over on top of DRBD and makes an abstraction of the running hosts
      versus the guests. It bundles a set of hosts (which it calls nodes) in
      logical groups called clusters. The guests (instances) are then spread
      across the nodes in the cluster, and the administrator manages the
      cluster remotely.</para>

      <para>Using virtualization has a whole set of advantages of which I'll
      try to mention a few in the next paragraphs. I will use the term
      <emphasis>host</emphasis> when talking about the host operating system
      (the one running or directly managing the hypervisor software) and
      <emphasis>guest</emphasis> for the virtualized operating system
      instances (that are running on the host).</para>

      <section>
        <title>High Availability</title>

        <para>In a virtualized environment, guests can be quickly restarted
        when needed. The host is still up and running, so rebooting a system
        is a matter of restarting a process. This has the advantage that
        caching and other performance measures taken by the hypervisor are
        still available, which makes bootup times of guests quite fast.</para>

        <para>But even in case of host downtime, given the right architecture,
        guests can be quickly started up again. By providing a hardware
        abstraction in the virtualization layer, these technologies are able
        to start a guest on a different hardware environment (even with
        different hardware, although there are limits to this - the most
        obvious one being that the new hardware must support the same
        architecture and virtualization). Many virtualization solutions can
        host guest storage (the guests' disks) in image files which can be
        made highly available through high-performance NFS shares, cluster
        filesystem or storage synchronisation. If the host crashes, the guest
        storage is quickly made available on a different host and the guest is
        restarted.</para>
      </section>

      <section>
        <title>Resource optimization</title>

        <para>For most organizations, virtualization is one of the most
        effective ways to optimize resources in their data rooms. Regular
        Unix/Windows servers generally consume lots of power, cooling and
        floor space while still only offering 15% (or less) of actual resource
        consumption (CPU cycles). 85% of the time, the system is literally
        doing nothing but waiting. With virtualization, you can have resources
        utilized better, going towards a healthy 80% while still allowing room
        for sudden resource burst demands.</para>
      </section>

      <section>
        <title>Flexible change management</title>

        <para>The virtualization layer also offers a way to do flexible change
        management. Because guests are now more tangible, it is easier to make
        snapshots of entire guests, copy them around, upgrade one instance
        and, if necessary, roll back to the previous snapshot - all this in
        just a few minutes or less. You can't do this with dedicated
        installations.</para>
      </section>

      <section>
        <title>"Secure" isolation</title>

        <para>In a security-sensitive environment, isolation is a very
        important concept. It ensures that a system or service can only access
        those resources it needs to, while disallowing (and even hiding) the
        other resources. Virtualization allows architects to design the system
        so that it runs in its own operating system, so from the viewpoint of
        the service, it has access to those resources it needs, but sees no
        other. On the host layer, the guests can then be properly isolated so
        they cannot influence each other.</para>

        <para>Having separate operating systems is often seen as a thorough
        implementation of "isolation". Yes, there are a lot of other means to
        isolate services. Still, running a service in a virtualized operating
        system is not the summum of isolation. <link
        xlink:href="http://blog.nelhage.com/2011/08/breaking-out-of-kvm/">Breaking
        out of KVM</link> has been done in the past, and will most likely
        happen again. Other virtualization have seen their share of security
        vulnerabilities to this level as well.</para>
      </section>

      <section>
        <title>Simplified backup/restore</title>

        <para>For many organizations, a bare-metal backup/restore routine is
        much more resource hungry than regular file-based backup/restore. By
        using virtualization, bare-metal backup/restore of the guests is a
        breeze, as it is now back a matter of working with files (and
        processes). Ok, the name "bare-metal" might not work anymore here -
        and you'll still need to backup your hypervisor. But if your
        hypervisor (host) installation is very standardized, this is much
        faster and easier than before.</para>
      </section>

      <section>
        <title>Fast deployment</title>

        <para>By leveraging the use of guest images, it is easy to create a
        single image and then use it as a master template for other instances.
        Need a web serving cluster? Set up on, replicate and boot. Need a few
        more during high load? Replicate and boot a few more. It becomes just
        that easy.</para>
      </section>
    </section>
  </section>

  <section>
    <title>Resources</title>

    <para>For more information about the topics in this chapter, you can
    divulge yourself in the information available at the following
    resources...</para>

    <para>Gentoo Hardened:</para>

    <itemizedlist>
      <listitem>
        <para><link
        xlink:href="http://www.gentoo.org/proj/en/hardened/pax-quickstart.xml">Hardened
        Gentoo PaX Quickstart</link> (Gentoo Linux)</para>
      </listitem>

      <listitem>
        <para><link xlink:href="http://hardened.gentoo.org">Gentoo Hardened
        project page</link> (Gentoo Linux)</para>
      </listitem>

      <listitem>
        <para><link
        xlink:href="http://eli.thegreenplace.net/2011/11/03/position-independent-code-pic-in-shared-libraries/">Position
        Independent Code</link> in shared libraries</para>
      </listitem>

      <listitem>
        <para><link
        xlink:href="http://www.gentoo.org/proj/en/hardened/pic-guide.xml">Introduction
        to Position Independent Code</link> (Gentoo Linux)</para>
      </listitem>

      <listitem>
        <para><link
        xlink:href="http://blog.fpmurphy.com/2008/06/position-independent-executables.html">Position
        Independent Executables</link></para>
      </listitem>

      <listitem>
        <para><link
        xlink:href="http://www.gentoo.org/proj/en/hardened/selinux/selinux-handbook.xml">Gentoo
        SELinux Handbook</link> (Gentoo Linux)</para>
      </listitem>

      <listitem>
        <para><link
        xlink:href="http://www.gentoo.org/proj/en/hardened/grsecurity.xml">Gentoo
        grSecurity v2 Guide</link> (Gentoo Linux)</para>
      </listitem>

      <listitem>
        <para><link
        xlink:href="http://dev.gentoo.org/~swift/docs/security_benchmarks/">Security
        benchmarks</link></para>
      </listitem>
    </itemizedlist>

    <para>KVM virtualization &amp; Ganeti:</para>

    <itemizedlist>
      <listitem>
        <para><link xlink:href="http://www.lancealbertson.com/">Lance
        Albertson's blog</link> (high focus on Ganeti and Gentoo)</para>
      </listitem>

      <listitem>
        <para><link
        xlink:href="http://docs.ganeti.org/ganeti/current/html/">Ganeti
        documentation</link></para>
      </listitem>

      <listitem>
        <para><link xlink:href="http://notes.ceondo.com/ganeti/">Ganeti
        deployment notes</link> (Céondo)</para>
      </listitem>
    </itemizedlist>
  </section>
</chapter>
