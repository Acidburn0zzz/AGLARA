<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="databaseserver"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title>Database Server</title>

  <section>
    <title>Introduction</title>

    <para>Databases are a prime subject for storing structured data. Be it as
    a backend for an LDAP system or DNS system, or as a structured storage for
    user data, or your most vital company secrets - databases offer a
    standardized method for storing and retrieving data. Thanks to wide driver
    support, many tools can interact with several database types (Oracle, SQL
    Server, PostgreSQL, MySQL, ...).</para>

    <para>In this section, we focus on the setup of PostgreSQL and
    MySQL.</para>
  </section>

  <section>
    <title>PostgreSQL</title>

    <para>Although (somewhat) less popular than MySQL, the PostgreSQL database
    is in my (humble) opinion a more stable and successful database platform.
    It is gaining momentum with vendors and has commercial backing by several
    companies - just in case you are in dire need for paying for software
    ;-)</para>

    <section>
      <title>Architecture</title>

      <para>Basically, postgresql is an almost monolithic system from a
      Unix/Linux point of view: not that many processes are involved. Of
      course, internally, that is a completely different thing.</para>

      <para>The PostgreSQL architecture looks like so:</para>

      <figure>
        <title>High-level architecture for PostgreSQL</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/07-postgresql.png" scalefit="0"
                       width="100%"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>Let's first look at how we would position the database in the
      reference architecture used in this book.</para>

      <section>
        <title>Feeds and flows</title>

        <para>As we are talking about a database, the most important flow we
        might expect is the backup/restore related one.</para>
      </section>

      <section>
        <title/>

        <para/>
      </section>
    </section>

    <section>
      <title>Installation</title>

      <para>The installation of PostgreSQL is quickly done in about three
      steps:</para>

      <orderedlist>
        <listitem>
          <para>installation of the software package</para>
        </listitem>

        <listitem>
          <para>securing of the database environment</para>
        </listitem>

        <listitem>
          <para>reloading the postgresql environment</para>
        </listitem>
      </orderedlist>

      <section>
        <title>Installation of the software package</title>

        <para>We start by installing the
        <package>dev-db/postgresql-server</package> package on the
        system.</para>

        <programlisting># <command>emerge dev-db/postgresql-server</command></programlisting>

        <para>Next, edit the /etc/conf.d/postgresql-9.1 file to accommodate
        the settings of the cluster.</para>

        <programlisting>PGDATA="/etc/postgresql-9.1"
DATA_DIR="/var/lib/postgresql/9.1/data"
PG_INITDB_OPTS="--locale=en_US.UTF-8"</programlisting>

        <para>Finally, create the cluster: temporarily assign a password to
        the postgres user (it will be asked during the configuration), and
        afterwards lock the account again.</para>

        <programlisting># <command>passwd postgres</command>
# <command>emerge --config dev-db/postgresql-server:9.1</command>
# <command>passwd -l postgres</command>
# <command>restorecon -Rv /var/lib/postgresql/9.1/data</command></programlisting>
      </section>

      <section>
        <title>Securing of the database environment</title>

        <para>To secure the cluster, we need to edit its configuration files
        before starting.</para>

        <para>Let's first make sure that we can connect to the database
        remotely too (by default, it only works locally). Edit the
        <filename>postgresql.conf</filename> file (in
        /<filename>etc/postgresql-9.1</filename>) and set the listen_addresses
        to the interface(s) you want the database to be reachable on.</para>

        <programlisting>listen_addresses=::1 2001:db8:81::204:de89:3312</programlisting>

        <para>Next, edit pg_hba.conf to allow remote connections for
        IPv6:</para>

        <programlisting>host    all     all      2001:db8:81::1/96    md5</programlisting>

        <para>Start the cluster and set the admin password:</para>

        <programlisting># <command>rc-service postgresql-9.1 start</command>
# <command>psql -U postgres</command>
postgres=# <command>\password</command>
postgres=# <command>\q</command></programlisting>
      </section>

      <section>
        <title>Reloading the postgresql environment</title>

        <para>With the password set, change the method in pg_hba.conf for the
        local (socket-based) connections from trust to password and reload the
        service</para>

        <programlisting># <command>rc-service postgresql-9.1 reload</command></programlisting>
      </section>
    </section>
  </section>

  <section>
    <title>MySQL</title>

    <para>The MySQL database platform is a very popular database, especially
    for web-based applications. Many software titles support MySQL as a
    database backend natively, so it makes sense to provide support for MySQL
    in our reference architecture as well.</para>

    <section>
      <title>Initial setup</title>

      <para>The initial setup of MySQL on Gentoo is a breeze. Install the
      <command>dev-db/mysql</command> package on your system and you're good
      to go. Next, make sure that the following entries are set in your
      /etc/mysql/my.cnf file:</para>

      <itemizedlist>
        <listitem>
          <para>local-infile=0 (in the [mysqld] section) to disable loading
          data from a local file from within MySQL</para>
        </listitem>
      </itemizedlist>

      <para>Furthermore, secure the environment through the following
      actions:</para>

      <itemizedlist>
        <listitem>
          <para>Look in all users' home directories for a file called
          .mysql_history, and remove it. Next, create a symlink to /dev/null
          called .mysql_history. This is because the history file contains the
          history of all commands executed, which can include sensitive
          information.</para>
        </listitem>
      </itemizedlist>

      <para>Now, create the initial database with
      <command>mysql_install_db</command> and start the database:</para>

      <programlisting># <command>rc-service mysql start</command></programlisting>

      <para>Then, call <command>mysql_secure_installation</command> to
      properly secure the database further.</para>
    </section>

    <section>
      <title>User management</title>

      <para>Currently, MySQL uses internal tables for managing user accounts.
      Work is on the way to support other authentication services, like LDAP,
      using the MySQL plugin support. But for now, let's stick with the
      internal user tables.</para>

      <para>For database users, I always tend to make distinction between
      (personal) accounts and (functional) application accounts.</para>

      <itemizedlist>
        <listitem>
          <para>Personal accounts are tied to a single person, and might even
          have DBA (or at least more) privileges</para>
        </listitem>

        <listitem>
          <para>Functional application accounts are tied to an application
          server (or set of servers) and are used to access the database
          data</para>
        </listitem>
      </itemizedlist>

      <para>Making the distinction is pretty much for security reasons, but
      also because functional accounts might be better off with a different
      authentication approach.</para>

      <section>
        <title>Authentication methods</title>

        <para>By default, MySQL uses password-based authentication (with the
        hashes of the database stored in the mysql.user table). The field is a
        SHA1 checksum of the binary representation of the SHA1 checksum of the
        password. For instance, if the password is "password", then you can
        generate the hash from the command line as follows:</para>

        <programlisting>$ <command>echo -n password | openssl dgst -sha1 -binary | sha1sum</command></programlisting>

        <para>Or you can use the mysql function:</para>

        <programlisting>mysql&gt; <command>SELECT PASSWORD('password');</command></programlisting>

        <para>Knowing how the hash works also allows you to manage the hashes
        remotely if you want.</para>
      </section>
    </section>
  </section>
</chapter>
